[
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by valueã€‚  ç­”æ¡ˆ: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by value  *èˆ‡call by referenceç›¸æ¯”å¯æ¸…æ¥šçœ‹å‡ºå·®ç•°ï¼Œå› æ­¤ä»¥call by referenceåšå°ç…§ã€‚   \t \t\t \t\t\t  \t\t\t \t\t\tCall by value \t\t\t \t\t\t \t\t\tcall by reference \t\t\t \t\t \t\t \t\t\t \t\t\tåƒæ•¸å€¼å½±éŸ¿ \t\t\t \t\t\t \t\t\tä¸¦ä¸æœƒæ”¹è®Šæ‰€å‘¼å«åƒæ•¸å€¼ï¼Œå› å‘¼å«çš„åªæ˜¯è©²è®Šæ•¸ç•¶æ™‚æ•¸å€¼ï¼Œä¸¦ä¸æ˜¯è©²è®Šæ•¸æœ¬èº« \t\t\t \t\t\t \t\t\tå‡½æ•¸å…§éƒ¨æ‰€åšçš„æ›´å‹•æœƒå½±éŸ¿å¯¦éš›åƒæ•¸ \t\t\t \t\t \t\t \t\t\t \t\t\tå„²å­˜ä½ç½® \t\t\t \t\t\t \t\t\tå‘¼å«çš„å‡½æ•¸å’Œä¸»ç¨‹å¼æ‰€ä½¿ç”¨åƒæ•¸çš„è¨˜æ†¶é«”ä½ç½®ä¸åŒ \t\t\t \t\t\t \t\t\tå‘¼å«çš„å‡½æ•¸å’Œä¸»ç¨‹å¼æ‰€ä½¿ç”¨åƒæ•¸çš„è¨˜æ†¶é«”ä½ç½®ç›¸åŒ",
        "output": "è©•è«–:Nice. è©•è«–:ğŸ‘ è©•è«–:è®š è©•è«–:å¥½è®š è©•è«–:è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by valueã€‚  ç­”æ¡ˆ: ç•¶functionä½¿ç”¨å‚³å€¼å‘¼å«( call by value )æ™‚  å³function åªæœƒè¤‡è£½è®Šæ•¸çš„å€¼ä¾†åšä½¿ç”¨ï¼Œä¸æœƒå½±éŸ¿å„²å­˜åœ¨åŸæœ¬è¨˜æ†¶é«”ä¸­çš„è®Šæ•¸æ•¸å€¼  ( æœ‰é»åƒå»å€Ÿæœ‹å‹èª²æœ¬å½±å°ï¼Œå°å®Œèª²æœ¬é‚„æ˜¯æœ‹å‹çš„ï¼Œå°å½±æœ¬é€²è¡Œå‰ªè²¼ã€ç­†è¨˜çš†ä¸æœƒå½±éŸ¿åŸä¾†çš„èª²æœ¬ )  èˆ‡ä¹‹ç›¸åçš„call by referenceå‰‡æ˜¯å°‡å„²å­˜è®Šæ•¸çš„è¨˜æ†¶é«”ä½ç½®å‚³çµ¦functionï¼Œä½¿å…¶å¯ä»¥ç›´æ¥å°è®Šæ•¸é€²è¡Œæ›´å‹•  ( ä»¥ä¸Šè¿°èˆ‰ä¾‹è€Œè¨€ï¼Œå°±åƒç›´æ¥åœ¨æœ‹å‹èª²æœ¬ä¸Šé€²è¡Œå‰ªè²¼ã€ç­†è¨˜ )  #include&lt;iostream&gt; using namespace std; void CallByValue( int n ) {     n += 1;     n *= 10; } // CallByValue void CallByReference( int &amp;n ){     n += 1;     n *= 10; } // CallByReference int main(){     int num = 1;     CallByValue(num);     cout &lt;&lt;  CallByValue :   &lt;&lt; num &lt;&lt; endl;     CallByReference(num);     cout &lt;&lt;  CallByReference :   &lt;&lt; num &lt;&lt; endl;     return 0; } // main()  ä»¥ä¸Šç¨‹å¼ç¢¼åœ¨CallByValueæ™‚ï¼Œè¼¸å‡ºç‚º1  åœ¨CallByReferenceæ™‚ï¼Œè¼¸å‡ºç‚º20  å…©ç¨®ç¨‹å¼çš†å°‡è®Šæ•¸é€²è¡Œç›¸åŒé‹ç®—  å¯çŸ¥ç•¶function call by valueæ™‚ åŸè®Šæ•¸å€¼ä¸æœƒå› functionå…§çš„å‹•ä½œè€Œæ”¹è®Š",
        "output": "è©•è«–:OK. è©•è«–:å¯«å¾—è »å®Œæ•´çš„ è®š è©•è«–:good è©•è«–:good! è©•è«–:å¥½è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by valueã€‚  ç­”æ¡ˆ: call by value(å‚³å€¼)ï¼š åƒæ•¸ä»¥æ•¸å€¼æ–¹å¼å‚³éï¼Œé¡§åæ€ç¾©æŠŠå€¼å‚³åˆ°å¦ä¸€å€‹è¨˜æ†¶é«”ä½ç½®çš„å€¼ä¸Š åœ¨cal by valueçš„æƒ…æ³ä¸‹ï¼Œå‘¼å«å‡½æ•¸æ‰€å‚³éçš„åƒæ•¸ä»¥åŠåƒæ•¸åœ°å€çš†ä¸æœƒè¢«æ”¹è®Šã€‚  call by reference(å‚³åƒè€ƒ)ï¼š æŠŠè¨˜æ†¶é«”ä½ç½®å‚³åˆ°ç§»åˆ°å¦ä¸€å€‹è¨˜æ†¶é«”ä½ç½®ä¸Š (å¯çœ‹ä½œåŒä¸€å€‹ç‰©ä»¶) åœ¨cal by referenceçš„æƒ…æ³ä¸‹ï¼Œå‘¼å«å‡½æ•¸æ‰€å‚³éçš„åƒæ•¸å¯ä»¥è¢«æ”¹è®Šï¼Œä½†åƒæ•¸åœ°å€ä¸¦ä¸æœƒè¢«æ”¹è®Šã€‚  #############  # include &lt;iostream&gt; using namespace std;  void TestRef(int &amp; ref) {     ref = ref * 10;     return ; } //TestRef  void TestVal(int val){     val = val * 10;     return; }// TestVal  int main() {          int ref = 10 , val = 10;     cout &lt;&lt;  1st ref&amp;val:   &lt;&lt; ref &lt;&lt;   /   &lt;&lt; val &lt;&lt; endl;          TestRef(ref);     TestVal(val);      cout &lt;&lt;  2nd ref&amp;val:   &lt;&lt; ref &lt;&lt;   /   &lt;&lt; val &lt;&lt; endl;     return 0;      } // main",
        "output": "è©•è«–:Good! è©•è«–:ğŸ‘ è©•è«–:good! è©•è«–:good è©•è«–:è®šå–”"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜åŒé¡åˆ¥å…©å€‹æ–¹æ³•å¦‚ä½•å¯¦ç¾å¤šè¼‰overloadingã€‚  ç­”æ¡ˆ: åœ¨C++ä¸­ï¼Œæœ‰ Function Overloading å’Œ Operator Overloadingï¼Œä½†æ­¤é¡Œæ˜¯è¦è¬›è¿° Function Overloading  é‚£ä»€éº¼æ˜¯Function Overloadingå‘¢? 1.åŒæ¨£åç¨±çš„å‡½æ•¸æœ‰å¤šç¨®æ ¼å¼ï¼Œæˆ–èªªå¤šå€‹å‡½æ•¸å…±ç”¨ä¸€å€‹å‡½æ•¸åç¨± 2.å¯ä»¥å®šç¾©å…©å€‹æœ‰ç›¸åŒåç¨±çš„å‡½æ•¸ï¼Œä½†å‡½æ•¸ç°½å (Signature) å¿…é ˆä¸åŒ    é‚£Function Overloadingæœ‰ä»€éº¼å¥½è™•å‘¢?  1. é¿å…è©çª®çš„å¥½è¾¦æ³•(æƒ³æƒ³å¦‚æœå‘½å20å¹¾å€‹Functionï¼Œä½†åšçš„äº‹æƒ…å¤§åŒå°ç•°) 2. å› ç‚ºå»ºæ§‹å­çš„åç¨±å¿…é ˆå’Œclass nameä¸€æ¨£ï¼Œå› æ­¤å¯ä»¥ç”¢ç”Ÿè¨±å¤šå»ºæ§‹å­è€Œä¸æœƒç™¼ç”ŸéŒ¯èª¤ 3. è®“å…¶ä»–é–‹ç™¼è€…èƒ½å¤ æ›´è¼•é¬†çš„å»ä½¿ç”¨ä½ æ‰€å¯«çš„API (ä¸ç”¨å»èƒŒæˆ–è€…æŸ¥è©¢å¾ˆå¤šåç¨±ï¼Œè€Œæ˜¯é€éå¸¶å…¥ä¸åŒåƒæ•¸å¾—å‡ºæƒ³è¦çš„çµæœ)  // ç”¨ä¾†ç¤ºç¯„çš„ä¸€å€‹ç¨‹å¼  #include&lt;bits/stdc++.h&gt; // æˆ‘å¾ˆæŠ±æ­‰  using namespace std; // æˆ‘çœŸçš„å¾ˆæŠ±æ­‰   // ç”¨ä¾†ç¤ºç¯„çš„ä¸€å€‹ç¨‹å¼  class Student{     public:         // æ²’æœ‰åƒæ•¸çš„å»ºæ§‹å­          Student(){             this -&gt; name =  ABC ;             this -&gt; studentID = 0;         }                  // å…·æœ‰åƒæ•¸çš„å»ºæ§‹å­         // è‡³æ–¼ç‚ºä»€éº¼å¯ä»¥è¾¦åˆ°å’Œå‰é¢çš„method name ä¸€æ¨£ æ˜¯å› ç‚ºæœ‰overloading         //           Student(int ID, string name){             this -&gt; name = name;             this -&gt; studentID = ID;         }                  // å–å¾—ID          int getID(){             return studentID;         }                  // å–å¾—åå­—          string getName(){             return name;         }                  // ä¸‹é¢å…©å€‹åå­—ä¸€æ¨£çš„Functionå¯ä»¥åŒæ™‚å­˜åœ¨ å› ç‚ºåƒæ•¸ä¸åŒ          void Change(int id){             this -&gt; studentID = id;         }                  // é€™æ¨£ä¾ç„¶å¯ä»¥å­˜åœ¨          void Change(char c){             printf( ç¬‘æ­»\\n );         }                  // ä½†åº•ä¸‹çš„å°±ä¸åˆæ³•äº† å› ç‚ºèˆ‡ä¸Šé¢çš„é‡è¤‡         // æ‰€ä»¥åœ¨ä½¿ç”¨overloadingçš„æ™‚å€™é‚„æ˜¯è¦å°å¿ƒ          /*         void Change(int k){             printf( %d\\n ,k);         }         */                           void Change(int id, string name){             this -&gt; studentID = id;             this -&gt; name = name;         }                  // æ³¨æ„ é€™æ¨£æ˜¯æœƒå‡ºéŒ¯çš„         // é›–ç„¶return typeä¸åŒ ä½†å¸¶å…¥çš„åƒæ•¸ç›¸åŒ å› æ­¤ç„¡æ³•åŒæ™‚å­˜åœ¨          /*         int Change(int c){             this -&gt; studentID = id             return 0;         }         */              // é˜²æ­¢å…¶ä»–åœ°æ–¹çš„ç¨‹å¼å»å­˜å–é€™å…©å€‹æ±è¥¿      private:         int studentID;         string name;          };  int main(){     Student a(12, 123 ); // Initialize through Constructor with arguments     Student b; // Initialize through Constructor without arguments     printf( %d\\n ,a.getID()); // 12     printf( %d\\n ,b.getID()); // 0          // åŒæ¨£æ˜¯Changeï¼Œä½†éš¨è‘—å¸¶å…¥çš„åƒæ•¸ä¸åŒï¼Œè€Œæœ‰ä¸åŒçš„æ•ˆæœ      a.Change(345);     b.Change(87, DEF );            printf( %d\\n ,a.getID()); // 345     printf( %s\\n ,a.getName().c_str()); // 123          printf( %d\\n ,b.getID()); // 87     printf( %s\\n ,b.getName().c_str()); // DEF }  é‚„æœ‰ä¸€å€‹æ±è¥¿å¾ˆå¸¸è¢«ææ·· é‚£å°±æ˜¯Override è‡³æ–¼ä»€éº¼æ˜¯Overrideï¼Œå°±å…ˆä¸è¨è«–äº†ï¼Œæœ‰èˆˆè¶£çš„äººå¯ä»¥Googleä¸€ä¸‹ (åƒè€ƒè³‡æº:  http://kaiching.org/pydoing/cpp/cpp-overload.html https://openhome.cc/Gossip/CppGossip/OverloadedFunction.html https://notfalse.net/58/overload)",
        "output": "è©•è«–:æœ‰æ–™ è©•è«–:ğŸ‘ è©•è«–:ğŸ‘ è©•è«–:è »å®Œæ•´çš„ç¯„ä¾‹åŠè§£èªªï¼Œçµ¦åƒè€ƒæ˜¯ä¸éŒ¯çš„ç¿’æ…£ã€‚  private data memberæ˜¯ä½œæ¥­#2å¿…é ˆåšåˆ°çš„ï¼Œprivate methodå‰‡å¯æœ‰å¯ç„¡ã€‚"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜åŒé¡åˆ¥å…©å€‹æ–¹æ³•å¦‚ä½•å¯¦ç¾å¤šè¼‰overloadingã€‚  ç­”æ¡ˆ: å¯ä»¥å®šç¾©ç›¸åŒåç¨±ä¹‹å‡½æ•¸ï¼Œä½†å¼•æ•¸å¿…é ˆä¸åŒ",
        "output": "è©•è«–:OK è©•è«–:ğŸ‘ è©•è«–:è®š è©•è«–:è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by valueã€‚  ç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;   vector &lt;int&gt; vec = {1, 2, 3, 4, 5, 6, 7, 8}; int main() {     for(auto i:vec) i=0; //call by value     for(auto i:vec)         cout &lt;&lt; i &lt;&lt;    ;      cout&lt;&lt;endl;     for(auto &amp;i:vec) i=0; //call by reference     for(auto i:vec)         cout &lt;&lt; i &lt;&lt;    ;  }  è¼¸å‡º    å¯è¦‹call bt valueæ˜¯è¤‡è£½æ–°çš„æ•¸ä¾†ä½¿ç”¨ï¼Œä¸¦ä¸æœƒä¿®æ”¹åˆ°åŸæœ¬çš„å€¼ã€‚",
        "output": "è©•è«–:è®š è©•è«–:è«‹ä¾é¡Œæ„è§£é‡‹ç¨‹å¼ç¢¼ã€‚  é™„è¨»ï¼š  1. æœ¬èª²ç¨‹ä½œæ¥­å‹¿ä½¿ç”¨ è¬èƒ½æ¨™é ­æª” ã€‚(ç†ç”±ï¼šæ¸…æ¥šèªçŸ¥ç¨‹å¼æ‰€ä½¿ç”¨çš„æ—¢æœ‰å‡½æ•¸)  2. æœ¬èª²ç¨‹ä½œæ¥­å‹¿ä½¿ç”¨autoè‡ªå‹•è®Šæ•¸ã€‚(ç†ç”±ï¼šæ¸…æ¥šèªçŸ¥ç¨‹å¼æ‰€ä½¿ç”¨çš„è®Šæ•¸å‹åˆ¥)"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by valueã€‚  ç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;  /* 1. Call by value :     main()ä¸­çš„è®Šæ•¸å€¼è¢«è¤‡è£½åˆ°å‰¯å‡½å¼swap_CallByValue()ï¼Œ     æ„å³ä½¿ç”¨çš„æ–°çš„è¨˜æ†¶é«”ä½å€ï¼Œä¸æœƒæ”¹å‹•åˆ°ä¸»å‡½å¼main()ä¸­çš„å€¼ï¼› */  void swap_CallByValue( int value1, int value2 ) {     int temp = value1;     value1 = value2;     value2 = temp;     cout &lt;&lt;  After swapped by using call by value in sub fucntion :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n ; } // swap_CallByValue()  /* 2. Call by address/pointer :     æœ¬è³ªä¸Šä¹Ÿæ˜¯ä¸€ç¨®call by valueï¼Œåªä¸éæ­¤valueå°±æ˜¯æŒ‡æ¨™ï¼Œè¤‡è£½çš„ä¹Ÿæ˜¯æŒ‡æ¨™ã€‚     ä¸»å‡½å¼main()å‚³å…¥ä½å€å¾Œï¼Œå‰¯å‡½å¼swap_CallByAddress()ä»¥æŒ‡æ¨™æŒ‡å‘è¨˜æ†¶é«”ä½å€ï¼›     ç”±æ–¼äº¤æ›äº†è¨˜æ†¶é«”ä½å€ï¼Œå› æ­¤å›åˆ°ä¸»å‡½å¼main()å¾ŒåŸæœ¬çš„å€¼æœƒäº¤æ›ã€‚ */  void swap_CallByAddress( int *address1, int *address2 ) {     int temp = *address1;     *address1 = *address2;     *address2 = temp; } // swap_CallByAddress()  /* 3. Call by reference :     åƒ…é™C++ï¼Œç›´æ¥å‚³å…¥ä½å€å»äº¤æ›ï¼Œæ‰€ä»¥å›åˆ°ä¸»å‡½å¼main()å¾ŒåŸæœ¬çš„å€¼ä¹Ÿæœƒäº¤æ›ã€‚     ç”±æ–¼call by addressæ˜¯ç”¨æŒ‡æ¨™æŒ‡å‘ä½å€ï¼Œå› æ­¤æŒ‡æ¨™æœ¬èº«ä¹Ÿå…·æœ‰ä½å€ï¼›     è€Œcall by referenceæ˜¯ç›´æ¥å‚³å…¥ä½å€ï¼Œæœ¬èº«ä¸å…·ä½å€ã€‚ */  void swap_CallByReference( int &amp;reference1, int &amp;reference2 ) {     int temp = reference1;     reference1 = reference2;     reference2 = temp; } // swap_CallByReference()  /* 4. æ¯”è¼ƒï¼š     ã€Call by valueã€‘ï¼š     (1)è‹¥ä½¿ç”¨å¤ªå¤šä¸”ä½¿ç”¨å®Œæ²’åˆªæ‰æœªä½¿ç”¨çš„è¨˜æ†¶é«”ç©ºé–“ï¼Œå¯èƒ½æœƒå°è‡´è¨˜æ†¶é«”ä¸è¶³è€Œç¨‹å¼å´©æ½°ã€‚     (2)ç”±æ–¼è¦è¤‡è£½å€¼ï¼Œå› æ­¤æ•ˆèƒ½è¼ƒå·®ã€è¼ƒæ…¢     (3)ä¸æœƒå½±éŸ¿åˆ°ä¸»å‡½å¼          ã€Call by address/pointerã€‘ï¼š     (1)ç”±æ–¼æ¥æ”¶çš„æ˜¯è¨˜æ†¶é«”ä½å€ï¼Œå› æ­¤åœ¨å‰¯å‡½å¼ä¸­çš„ä»»ä½•è®Šå‹•éƒ½å¯èƒ½å½±éŸ¿åˆ°ä¸»å‡½å¼ã€‚     (2)ä¹Ÿæ˜¯ä¸€ç¨®call by value1          ã€Call by referenceã€‘ï¼š     (1)åƒ…é™C++     (2)æœƒæª¢æŸ¥è¨˜æ†¶é«”ä½ç½®æ˜¯å¦åˆæ³•         ex.             int iVal = 10;             int &amp;refVal = iVal; // åˆæ³•             int &amp;refVal; // éæ³•ï¼Œæœªåˆå§‹åŒ–             (error: &lsquo;refVal&rsquo; declared as reference but not initialized)             int &amp;refVal = 0; // éæ³•ï¼Œåˆå€¼å¿…é ˆæ˜¯ç‰©ä»¶             (error: cannot bind non-const lvalue reference of type &lsquo;int&amp;&rsquo; to an rvalue of type &lsquo;int&rsquo;)     (3)ç•¶ä½œç‰©ä»¶çš„åˆ¥å(alias)ä½¿ç”¨          ã€æ•ˆèƒ½æ¯”è¼ƒã€‘ï¼š     Call by reference = Call by address &gt; Call by value */  int main() {     int value1 = 10, value2 = 20;     cout &lt;&lt;  The original values of call by value :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n ;     swap_CallByValue( value1, value2 );     cout &lt;&lt;  After swapped by using call by value in main fucntion :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n\\n ;          int address1 = 30, address2 = 40;     cout &lt;&lt;  The original values of call by address :\\naddress1 is   &lt;&lt; address1 &lt;&lt;   and address2 is   &lt;&lt; address2 &lt;&lt;  \\n ;     swap_CallByAddress( &amp;address1, &amp;address2 );     cout &lt;&lt;  After swapped by using call by address :\\naddress1 is   &lt;&lt; address1 &lt;&lt;   and address2 is   &lt;&lt; address2 &lt;&lt;  \\n\\n ;          int reference1 = 50, reference2 = 60;     cout &lt;&lt;  The original values of call by reference :\\nreference1 is   &lt;&lt; reference1 &lt;&lt;   and reference2 is   &lt;&lt; reference2 &lt;&lt;  \\n ;     swap_CallByReference( reference1, reference2 );     cout &lt;&lt;  After swapped by using call by reference :\\nreference1 is   &lt;&lt; reference1 &lt;&lt;   and reference2 is   &lt;&lt; reference2 &lt;&lt;  \\n\\n ;     return 0; } // main()  è¼¸å‡ºï¼š    åƒç…§ï¼š  https://dotblogs.com.tw/Ace_Dream/2016/06/01/callbyvalue_callbyaddress_callbyreference  https://hackmd.io/@yunfanlu/r1xryJdSI#Call-by-reference",
        "output": "è©•è«–:Excellent summary! è©•è«–:Good."
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by valueã€‚  ç­”æ¡ˆ: call by value:ç•¶å‰¯ç¨‹å¼å‘¼å«ä¸»ç¨‹å¼çš„å€¼å¾ŒæœƒæŠŠåŸæœ¬åœ¨è¨˜æ†¶é«”è£¡é¢çš„å€¼è¤‡è£½ä¹‹å¾Œï¼Œå°‡è¤‡è£½å¾Œçš„å€¼å‚³åˆ°å¦ä¸€å€‹è¨˜æ†¶é«”çš„ä½ç½®ä¸Šï¼Œè€Œå‰¯ç¨‹å¼çš„å€¼å°±æ˜¯ä½¿ç”¨è¤‡è£½å¾Œçš„è¨˜æ†¶é«”ä½ç½®ï¼Œå› æ­¤é‚£å€‹å€¼å¦‚ä½•æ›´æ”¹éƒ½ä¸æœƒæ”¹è®Šä¸»ç¨‹å¼åŸæœ¬çš„å€¼ã€‚   call by reference: ç•¶å‰¯ç¨‹å¼å‘¼å«ä¸»ç¨‹å¼çš„å€¼å¾Œæœƒç›´æ¥å–ä¸»ç¨‹å¼çš„å€¼çš„è¨˜æ†¶é«”ä½ç½®ï¼Œå› æ­¤ä¹‹å¾Œçš„è®Šå‹•éƒ½æ˜¯åœ¨åŒä¸€å€‹è¨˜æ†¶é«”åšé‹ç®—ï¼Œæ‰€ä»¥å›åˆ°ä¸»ç¨‹å¼å¾Œå¾—åˆ°çš„å€¼æ˜¯æœƒéš¨è‘—é‹ç®—è®Šå‹•ã€‚",
        "output": "è©•è«–:ğŸ‘ è©•è«–:GoodğŸ‘ è©•è«–:ğŸ‘ è©•è«–:è®šå–”  è§£èªªå¾ˆè©³ç´° è©•è«–:ä¸éŒ¯"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å¯«å‡ºC++ç¨‹å¼ç¢¼èªªæ˜å‚³å€¼å‘¼å«call by valueã€‚  ç­”æ¡ˆ: call by valueå¼•ç”¨è®Šæ•¸æ•¸å€¼è€Œcall by referenceå¼•ç”¨è®Šæ•¸æœ¬èº«ï¼Œç•¶å«æœ‰call by valueåƒæ•¸çš„å‡½æ•¸è¢«å‘¼å«æ™‚ï¼Œ è©²è®Šæ•¸æ•¸å€¼æœƒè¢«è¤‡è£½ï¼Œå‡½æ•¸åªèƒ½æ”¹å‹•è¤‡è£½å¾Œçš„å€¼ã€‚è€Œcall by referenceå‰‡ä¸è¤‡è£½ï¼Œèˆ‡ä¸»ç¨‹å¼è®Šæ•¸ä½¿ç”¨ç›¸åŒçš„è¨˜æ†¶é«”ä½ç½®ã€‚  call by value å› ç‚ºè¦è¤‡è£½åƒæ•¸çš„å€¼ï¼Œåœ¨å‘¼å«ä¸ŠæœƒèŠ±è¼ƒå¤šæ™‚é–“ï¼Œå½±éŸ¿æ•ˆèƒ½ï¼Œä½†å¯ä¿è­·ä¸»ç¨‹å¼çš„å€¼ä¸è¢«ä»»æ„æ›´æ”¹ã€‚  call by reference -&gt; èˆ‡call by value ç›¸æ¯”è¼ƒä¸å½±éŸ¿æ•ˆèƒ½ï¼Œä½†æœ‰æ™‚ä¸¦ä¸å¸Œæœ›ä¸»ç¨‹å¼çš„å€¼è¢«æ›´å‹•ã€‚  # include &lt;iostream&gt; using namespace std;  void RefAndVal( int &amp; ref, int val ) {     ref = ref * 2;     val = val * 2; } // ByReference  int main() {     int ref = 5 , val = 5;     cout &lt;&lt;  Before :   &lt;&lt; ref &lt;&lt; endl;     cout &lt;&lt;  After call by reference :   &lt;&lt; ref &lt;&lt; endl;     cout &lt;&lt;  After call by value :   &lt;&lt; val &lt;&lt; endl;      return 0; } // main",
        "output": "è©•è«–:Good! è©•è«–:ğŸ‘ è©•è«–:good! è©•è«–:ğŸ‘ è©•è«–:goodddddd"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹å•é¡Œçš„å›ç­”ä½œå‡ºè©•è«–ï¼Œä¸¦åˆ¤æ–·å›ç­”æ˜¯å¦æ­£ç¢º",
        "input": "é¡Œç›®: å°‡æ­¤å¾Œåºå¼postfixè½‰ä¸­åºå¼infixï¼Œä¸¦è©³è¿°æ­¥é©Ÿã€‚a b + c * d e + f * + w z + *  ç­”æ¡ˆ: æˆ‘çš„ä½œæ³•æ˜¯å…ˆæŠŠé€™å€‹ä»¥å¾Œåºè¡¨ç¤ºæ³•è¡¨ç¤ºçš„å¼å­ä»¥äºŒå…ƒæ¨¹çš„æ–¹å¼å„²å­˜(é€™å€‹äºŒå…ƒæ¨¹ç¶“Postorder traversalå¾Œæœƒå¾—åˆ°åŸæœ¬å¾ŒçºŒå¾Œåºè¡¨ç¤ºæ³•çš„å¼å­) å› ç‚ºåœ¨ä¸­åºè¡¨ç¤ºæ³•ä¸­ï¼Œä¹˜æ³•åŠé™¤æ³•çš„é‹ç®—å„ªå…ˆé †åºé«˜æ–¼åŠ æ³•åŠæ¸›æ³•ï¼Œä¹Ÿå°±æ˜¯èªªä¸­åºè¡¨ç¤ºæ³•éœ€è€ƒæ…®é‹ç®—å…ƒçš„å„ªå…ˆé †åºã€‚ æ‰€ä»¥ç•¶é‹ç®—å„ªå…ˆé †åºè¼ƒé«˜çš„ç¯€é»ï¼Œå…¶å·¦ç¯€é»æˆ–å³ç¯€é»çš„é‹ç®—å„ªå…ˆé †åºä½æ–¼æ­¤ç¯€é»ï¼Œ è¡¨ç¤ºåœ¨ä¸­åºè¡¨ç¤ºæ³•ä¸­ï¼Œéœ€å°‡å·¦ç¯€é»æˆ–å³ç¯€é»è¡¨ç¤ºæˆä¸­åºè¡¨ç¤ºæ³•å¾Œï¼Œåœ¨å…¶å·¦å³å…©é‚ŠåŠ ä¸Šæ‹¬è™Ÿï¼Œæ‰èƒ½è®“å·¦ç¯€é»æˆ–å³ç¯€é»èƒ½å¤ å…ˆè¢«è¨ˆç®—ã€‚  éç¨‹:    ä»¥ a b + c * d e + f * + w z + * å»ºå‡ºä¾†çš„äºŒå…ƒæ¨¹é•·çš„åƒæ˜¯é€™æ¨£ï¼Œå…¶ä¸­é»‘åº•å­—è¡¨ç¤ºçš„æ˜¯æ­¤ç«¯é»è½‰æˆä¸­åºè¡¨ç¤ºå¼çš„çµæœã€‚    ä»¥C++å¯¦ä½œå¤§æ¦‚æ˜¯",
        "output": "è©•è«–:1.  å…ˆæŠŠé€™å€‹ä»¥å¾Œåºè¡¨ç¤ºæ³•è¡¨ç¤ºçš„å¼å­ä»¥äºŒå…ƒæ¨¹çš„æ–¹å¼å„²å­˜  æœªè§£èªªç¬¬ä¸€æ­¥å¦‚ä½•å»ºæ¨¹ï¼Ÿ  2. å®Œå…¨æ²’æœ‰è¨»è§£çš„ç¨‹å¼ç¢¼ï¼Ÿ  3."
    }
]