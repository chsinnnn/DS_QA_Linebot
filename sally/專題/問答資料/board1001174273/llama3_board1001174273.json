[
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 在C++中，有 Function Overloading 和 Operator Overloading，但此題是要講述 Function Overloading\n\n那什麼是Function Overloading呢?\n1.同樣名稱的函數有多種格式，或說多個函數共用一個函數名稱\n2.可以定義兩個有相同名稱的函數，但函數簽名 (Signature) 必須不同\n \n\n那Function Overloading有什麼好處呢?\n\n1. 避免詞窮的好辦法(想想如果命名20幾個Function，但做的事情大同小異)\n2. 因為建構子的名稱必須和class name一樣，因此可以產生許多建構子而不會發生錯誤\n3. 讓其他開發者能夠更輕鬆的去使用你所寫的API (不用去背或者查詢很多名稱，而是透過帶入不同參數得出想要的結果)\n\n// 用來示範的一個程式 \n#include&lt;bits/stdc++.h&gt; // 我很抱歉 \nusing namespace std; // 我真的很抱歉 \n\n// 用來示範的一個程式 \nclass Student{\n    public:\n        // 沒有參數的建構子 \n        Student(){\n            this -&gt; name =  ABC ;\n            this -&gt; studentID = 0;\n        }\n        \n        // 具有參數的建構子\n        // 至於為什麼可以辦到和前面的method name 一樣 是因為有overloading\n        //  \n        Student(int ID, string name){\n            this -&gt; name = name;\n            this -&gt; studentID = ID;\n        }\n        \n        // 取得ID \n        int getID(){\n            return studentID;\n        }\n        \n        // 取得名字 \n        string getName(){\n            return name;\n        }\n        \n        // 下面兩個名字一樣的Function可以同時存在 因為參數不同 \n        void Change(int id){\n            this -&gt; studentID = id;\n        }\n        \n        // 這樣依然可以存在 \n        void Change(char c){\n            printf( 笑死\\n );\n        }\n        \n        // 但底下的就不合法了 因為與上面的重複\n        // 所以在使用overloading的時候還是要小心 \n        /*\n        void Change(int k){\n            printf( %d\\n ,k);\n        }\n        */\n        \n        \n        void Change(int id, string name){\n            this -&gt; studentID = id;\n            this -&gt; name = name;\n        }\n        \n        // 注意 這樣是會出錯的\n        // 雖然return type不同 但帶入的參數相同 因此無法同時存在 \n        /*\n        int Change(int c){\n            this -&gt; studentID = id\n            return 0;\n        }\n        */\n        \n    // 防止其他地方的程式去存取這兩個東西 \n    private:\n        int studentID;\n        string name;    \n    \n};\n\nint main(){\n    Student a(12, 123 ); // Initialize through Constructor with arguments\n    Student b; // Initialize through Constructor without arguments\n    printf( %d\\n ,a.getID()); // 12\n    printf( %d\\n ,b.getID()); // 0\n    \n    // 同樣是Change，但隨著帶入的參數不同，而有不同的效果 \n    a.Change(345);\n    b.Change(87, DEF );  \n    \n    printf( %d\\n ,a.getID()); // 345\n    printf( %s\\n ,a.getName().c_str()); // 123\n    \n    printf( %d\\n ,b.getID()); // 87\n    printf( %s\\n ,b.getName().c_str()); // DEF\n}\n\n還有一個東西很常被搞混 那就是Override\n至於什麼是Override，就先不討論了，有興趣的人可以Google一下\n(參考資源: \nhttp://kaiching.org/pydoing/cpp/cpp-overload.html\nhttps://openhome.cc/Gossip/CppGossip/OverloadedFunction.html\nhttps://notfalse.net/58/overload)",
        "output": "蠻完整的範例及解說，給參考是不錯的習慣。\n\nprivate data member是作業#2必須做到的，private method則可有可無。 👍 👍 有料"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 我的作法是先把這個以後序表示法表示的式子以二元樹的方式儲存(這個二元樹經Postorder traversal後會得到原本後續後序表示法的式子)\n因為在中序表示法中，乘法及除法的運算優先順序高於加法及減法，也就是說中序表示法需考慮運算元的優先順序。\n所以當運算優先順序較高的節點，其左節點或右節點的運算優先順序低於此節點，\n表示在中序表示法中，需將左節點或右節點表示成中序表示法後，在其左右兩邊加上括號，才能讓左節點或右節點能夠先被計算。\n\n過程:\n\n\n\n以 a b + c * d e + f * + w z + * 建出來的二元樹長的像是這樣，其中黑底字表示的是此端點轉成中序表示式的結果。\n\n\n\n以C++實作大概是",
        "output": "1.  先把這個以後序表示法表示的式子以二元樹的方式儲存  未解說第一步如何建樹？\n\n2. 完全沒有註解的程式碼？\n\n3."
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: #include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n\nvector &lt;int&gt; vec = {1, 2, 3, 4, 5, 6, 7, 8};\nint main()\n{\n    for(auto i:vec) i=0; //call by value\n    for(auto i:vec)\n        cout &lt;&lt; i &lt;&lt;    ;\n\n    cout&lt;&lt;endl;\n    for(auto &amp;i:vec) i=0; //call by reference\n    for(auto i:vec)\n        cout &lt;&lt; i &lt;&lt;    ;\n\n}\n\n輸出\n\n\n\n可見call bt value是複製新的數來使用，並不會修改到原本的值。",
        "output": "讚 請依題意解釋程式碼。\n\n附註：\n\n1. 本課程作業勿使用 萬能標頭檔 。(理由：清楚認知程式所使用的既有函數)\n\n2. 本課程作業勿使用auto自動變數。(理由：清楚認知程式所使用的變數型別)"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: #include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n/*\n1. Call by value :\n    main()中的變數值被複製到副函式swap_CallByValue()，\n    意即使用的新的記憶體位址，不會改動到主函式main()中的值；\n*/\n\nvoid swap_CallByValue( int value1, int value2 ) {\n    int temp = value1;\n    value1 = value2;\n    value2 = temp;\n    cout &lt;&lt;  After swapped by using call by value in sub fucntion :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n ;\n} // swap_CallByValue()\n\n/*\n2. Call by address/pointer :\n    本質上也是一種call by value，只不過此value就是指標，複製的也是指標。\n    主函式main()傳入位址後，副函式swap_CallByAddress()以指標指向記憶體位址；\n    由於交換了記憶體位址，因此回到主函式main()後原本的值會交換。\n*/\n\nvoid swap_CallByAddress( int *address1, int *address2 ) {\n    int temp = *address1;\n    *address1 = *address2;\n    *address2 = temp;\n} // swap_CallByAddress()\n\n/*\n3. Call by reference :\n    僅限C++，直接傳入位址去交換，所以回到主函式main()後原本的值也會交換。\n    由於call by address是用指標指向位址，因此指標本身也具有位址；\n    而call by reference是直接傳入位址，本身不具位址。\n*/\n\nvoid swap_CallByReference( int &amp;reference1, int &amp;reference2 ) {\n    int temp = reference1;\n    reference1 = reference2;\n    reference2 = temp;\n} // swap_CallByReference()\n\n/*\n4. 比較：\n    【Call by value】：\n    (1)若使用太多且使用完沒刪掉未使用的記憶體空間，可能會導致記憶體不足而程式崩潰。\n    (2)由於要複製值，因此效能較差、較慢\n    (3)不會影響到主函式\n    \n    【Call by address/pointer】：\n    (1)由於接收的是記憶體位址，因此在副函式中的任何變動都可能影響到主函式。\n    (2)也是一種call by value1\n    \n    【Call by reference】：\n    (1)僅限C++\n    (2)會檢查記憶體位置是否合法\n        ex.\n            int iVal = 10;\n            int &amp;refVal = iVal; // 合法\n            int &amp;refVal; // 非法，未初始化\n            (error: &lsquo;refVal&rsquo; declared as reference but not initialized)\n            int &amp;refVal = 0; // 非法，初值必須是物件\n            (error: cannot bind non-const lvalue reference of type &lsquo;int&amp;&rsquo; to an rvalue of type &lsquo;int&rsquo;)\n    (3)當作物件的別名(alias)使用\n    \n    【效能比較】：\n    Call by reference = Call by address &gt; Call by value\n*/\n\nint main() {\n    int value1 = 10, value2 = 20;\n    cout &lt;&lt;  The original values of call by value :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n ;\n    swap_CallByValue( value1, value2 );\n    cout &lt;&lt;  After swapped by using call by value in main fucntion :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n\\n ;\n    \n    int address1 = 30, address2 = 40;\n    cout &lt;&lt;  The original values of call by address :\\naddress1 is   &lt;&lt; address1 &lt;&lt;   and address2 is   &lt;&lt; address2 &lt;&lt;  \\n ;\n    swap_CallByAddress( &amp;address1, &amp;address2 );\n    cout &lt;&lt;  After swapped by using call by address :\\naddress1 is   &lt;&lt; address1 &lt;&lt;   and address2 is   &lt;&lt; address2 &lt;&lt;  \\n\\n ;\n    \n    int reference1 = 50, reference2 = 60;\n    cout &lt;&lt;  The original values of call by reference :\\nreference1 is   &lt;&lt; reference1 &lt;&lt;   and reference2 is   &lt;&lt; reference2 &lt;&lt;  \\n ;\n    swap_CallByReference( reference1, reference2 );\n    cout &lt;&lt;  After swapped by using call by reference :\\nreference1 is   &lt;&lt; reference1 &lt;&lt;   and reference2 is   &lt;&lt; reference2 &lt;&lt;  \\n\\n ;\n    return 0;\n} // main()\n\n輸出：\n\n\n\n參照：\n\nhttps://dotblogs.com.tw/Ace_Dream/2016/06/01/callbyvalue_callbyaddress_callbyreference\n\nhttps://hackmd.io/@yunfanlu/r1xryJdSI#Call-by-reference",
        "output": "Excellent summary! Good."
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 當function使用傳值呼叫( call by value )時\n\n即function 只會複製變數的值來做使用，不會影響儲存在原本記憶體中的變數數值\n\n( 有點像去借朋友課本影印，印完課本還是朋友的，對影本進行剪貼、筆記皆不會影響原來的課本 )\n\n與之相反的call by reference則是將儲存變數的記憶體位置傳給function，使其可以直接對變數進行更動\n\n( 以上述舉例而言，就像直接在朋友課本上進行剪貼、筆記 )\n\n#include&lt;iostream&gt;\nusing namespace std;\nvoid CallByValue( int n ) {\n    n += 1;\n    n *= 10;\n} // CallByValue\nvoid CallByReference( int &amp;n ){\n    n += 1;\n    n *= 10;\n} // CallByReference\nint main(){\n    int num = 1;\n    CallByValue(num);\n    cout &lt;&lt;  CallByValue :   &lt;&lt; num &lt;&lt; endl;\n    CallByReference(num);\n    cout &lt;&lt;  CallByReference :   &lt;&lt; num &lt;&lt; endl;\n    return 0;\n} // main()\n\n以上程式碼在CallByValue時，輸出為1\n\n在CallByReference時，輸出為20\n\n兩種程式皆將變數進行相同運算\n\n可知當function call by value時 原變數值不會因function內的動作而改變",
        "output": "寫得蠻完整的 讚 好讚 good! OK. good"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 寫出C++程式碼說明傳值呼叫call by value\n\n*與call by reference相比可清楚看出差異，因此以call by reference做對照。\n\n\n\t\n\t\t\n\t\t\t \n\t\t\t\n\t\t\tCall by value\n\t\t\t\n\t\t\t\n\t\t\tcall by reference\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t參數值影響\n\t\t\t\n\t\t\t\n\t\t\t並不會改變所呼叫參數值，因呼叫的只是該變數當時數值，並不是該變數本身\n\t\t\t\n\t\t\t\n\t\t\t函數內部所做的更動會影響實際參數\n\t\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t儲存位置\n\t\t\t\n\t\t\t\n\t\t\t呼叫的函數和主程式所使用參數的記憶體位置不同\n\t\t\t\n\t\t\t\n\t\t\t呼叫的函數和主程式所使用參數的記憶體位置相同",
        "output": "👍 讚 Nice. 讚 好讚"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 可以定義相同名稱之函數，但引數必須不同",
        "output": "👍 OK 讚 讚"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: call by value引用變數數值而call by reference引用變數本身，當含有call by value參數的函數被呼叫時， 該變數數值會被複製，函數只能改動複製後的值。而call by reference則不複製，與主程式變數使用相同的記憶體位置。\n\ncall by value 因為要複製參數的值，在呼叫上會花較多時間，影響效能，但可保護主程式的值不被任意更改。\n\ncall by reference -&gt; 與call by value 相比較不影響效能，但有時並不希望主程式的值被更動。\n\n# include &lt;iostream&gt;\nusing namespace std;\n\nvoid RefAndVal( int &amp; ref, int val ) {\n    ref = ref * 2;\n    val = val * 2;\n} // ByReference\n\nint main() {\n    int ref = 5 , val = 5;\n    cout &lt;&lt;  Before :   &lt;&lt; ref &lt;&lt; endl;\n    cout &lt;&lt;  After call by reference :   &lt;&lt; ref &lt;&lt; endl;\n    cout &lt;&lt;  After call by value :   &lt;&lt; val &lt;&lt; endl; \n    return 0;\n} // main",
        "output": "goodddddd 👍 👍 Good! good!"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: call by value(傳值)：\n參數以數值方式傳遞，顧名思義把值傳到另一個記憶體位置的值上\n在cal by value的情況下，呼叫函數所傳遞的參數以及參數地址皆不會被改變。\n\ncall by reference(傳參考)：\n把記憶體位置傳到移到另一個記憶體位置上 (可看作同一個物件)\n在cal by reference的情況下，呼叫函數所傳遞的參數可以被改變，但參數地址並不會被改變。\n\n#############\n\n# include &lt;iostream&gt;\nusing namespace std;\n\nvoid TestRef(int &amp; ref) {\n    ref = ref * 10;\n    return ;\n} //TestRef\n\nvoid TestVal(int val){\n    val = val * 10;\n    return;\n}// TestVal\n\nint main() {\n    \n    int ref = 10 , val = 10;\n    cout &lt;&lt;  1st ref&amp;val:   &lt;&lt; ref &lt;&lt;   /   &lt;&lt; val &lt;&lt; endl;\n    \n    TestRef(ref);\n    TestVal(val);\n\n    cout &lt;&lt;  2nd ref&amp;val:   &lt;&lt; ref &lt;&lt;   /   &lt;&lt; val &lt;&lt; endl;\n    return 0;\n    \n} // main",
        "output": "👍 Good! good! good 讚喔"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: ***call by value和call by reference的差異***\n\ncall by value: 複製之後，把 值 傳到另一個 記憶體位置的值 上，因此呼叫者不能更改值。\ncall by reference: 本身變數沒有位置，值被存在某個記憶體位置，而存在這個變數內的就是這個記憶體位置，因此可改動。\n\n另外在速度效能方面call by value的速度會比call by reference慢，因為call by value要先複製一份之後再回傳。\n\n程式碼:\n\n#include&lt;iostream&gt;\nusing namespace std;\nvoid callByvalue( int a, int b )\n{\n    int temp;\n    temp = a;\n    a = b;\n    b = temp;\n} // void callByvalue\n\nvoid callByreference( int &amp;a, int &amp;b )\n{\n    int temp;\n    temp = a;\n    a = b;\n    b = temp;\n} // void callByreference\n\nint main()\n{\n    int a = 5, b = 3;\n    cout &lt;&lt;   Before a=   &lt;&lt; a &lt;&lt;   , b=  &lt;&lt; b &lt;&lt; endl;\n    callByvalue( a, b );\n    cout &lt;&lt; endl &lt;&lt;  After  &lt;&lt; endl;\n    cout &lt;&lt;  Call by value:  a=   &lt;&lt; a &lt;&lt;   , b=  &lt;&lt; b &lt;&lt; endl;\n    a = 5, b = 3;\n    callByreference( a, b );\n    cout &lt;&lt;  Call by reference:  a=   &lt;&lt; a &lt;&lt;   , b=  &lt;&lt; b &lt;&lt; endl;\n} // main()\n\n\n---方程式內進行a,b交換，由此證明call by value不會因為做任意運算就更改值。",
        "output": ""
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: call by value:當副程式呼叫主程式的值後會把原本在記憶體裡面的值複製之後，將複製後的值傳到另一個記憶體的位置上，而副程式的值就是使用複製後的記憶體位置，因此那個值如何更改都不會改變主程式原本的值。\n\n\ncall by reference: 當副程式呼叫主程式的值後會直接取主程式的值的記憶體位置，因此之後的變動都是在同一個記憶體做運算，所以回到主程式後得到的值是會隨著運算變動。",
        "output": "👍 Good👍 👏 不錯 讚喔\n\n解說很詳細"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 如題。\n到目前為止，共計50位同學問答已得分。",
        "output": ""
    }
]