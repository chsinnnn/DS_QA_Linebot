[
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: é€™é¡Œä¸»è¦æ˜¯åˆªæ‰ç¬¬ä¸‰å€‹ç¯€é» è‡³æ–¼æ€éº¼åšå‘¢? å°±æ˜¯å…ˆå–å¾—ç¬¬äºŒå€‹ç¯€é» å†è®“ç¬¬äºŒå€‹ç¯€é»çš„nextè¨­æˆç¬¬å››å€‹ç¯€é»   #include&lt;bits/stdc++.h&gt; // é€™çœŸçš„æ˜¯ä¸å¥½çš„ç¤ºç¯„ ä¸è¦äº‚ä½¿ç”¨ using namespace std; // é€™ä¹Ÿæ˜¯å€‹éå¸¸ä¸å¥½çš„ç¤ºç¯„ // Node // åˆ©ç”¨æ³›å‹å¯¦ä½œ template &lt;typename T&gt; struct Node {     T num; // è³‡æ–™     Node * next; };  // åˆ©ç”¨æ³›å‹å¯¦ä½œLinkedList // æ®˜ç¼ºçš„LinkedList, ä¸éå¯ä»¥æ‡‰ä»˜é€™é¡Œ template &lt;typename T&gt; class LinkedList {     public:         // å»ºæ§‹å­         // åˆå§‹åŒ–è³‡æ–™         LinkedList() {             head = NULL;             tail = NULL;             size = 0;         }          // æŠŠè³‡æ–™æ”¾é€²å»         void push(T data) {             // å¦‚æœè£¡é¢ç©ºç©ºçš„             if(size==0) {                 head = new Node&lt;T&gt;; // è®“headè®Šæˆæ–°çš„Node                 head -&gt; num = data; // æŠŠè³‡æ–™æ”¾é€²å»                 head -&gt; next = NULL; // æŒ‡å®šheadçš„nextæ˜¯null                 size++; // è®“size++                 tail = head;// è®“tailè®Šæˆhead                 return; // return å›å» é¿å…é€²å…¥ä¸‹ä¸€è¡Œ             }              // è¦æ˜¯ä¸æ˜¯ç©ºçš„è©±             tail -&gt; next = new Node&lt;T&gt;; // å…ˆè®“tailçš„ä¸‹ä¸€å€‹è®Šæˆæ–°çš„Node             tail = tail -&gt; next; // æŠŠtail ç§»åˆ°ä¸‹ä¸€å±¤             tail -&gt; num = data;// æŠŠè³‡æ–™æ”¾é€²å»             tail -&gt; next = NULL; // tailçš„ä¸‹ä¸€å€‹æŒ‡å®šç‚ºNULL             size++;// sizeå¢åŠ              return;// return å›å» å¯åŠ å¯ä¸åŠ          }          // å–®ç´”çš„è¤‡è£½LinkedList         // é€™é‚Šæ˜¯ç”¢ç”Ÿä¸€å€‹æ–°çš„LinkedList è€Œä¸æ˜¯æŠŠåŸæœ¬çš„returnå›å»         // å› ç‚ºå¦‚æœæ˜¯æŠŠåŸæœ¬çš„returnå›å»ï¼Œæœƒå°è‡´è³‡æ–™æœƒè¢«äº’ç›¸å¼•éŸ¿         LinkedList copy() {             LinkedList toReturn; // æº–å‚™å›å‚³å›å»çš„è³‡æ–™             Node&lt;T&gt; * temp = head; // æŒ‡æ¨™ ç”¨ä¾†èµ°è¨ªæ•´å€‹LinkedList             while(temp!=NULL) {                 toReturn.push(temp-&gt;num); // é€éæ–¹æ³•ä¸€ç›´å»pushè³‡æ–™                 temp = temp -&gt; next;             }             return toReturn; // return          }          // é€é index å»å–å¾—è³‡æ–™         T getDataFromIndex(int k) {             Node&lt;T&gt; * temp = getFromIndex(k);             return temp -&gt; num;         }          // é€éindex ç§»é™¤è³‡æ–™ ä¸¦ä¸”å°‡è³‡æ–™å›å‚³          T removeFromIndex(int k) {             Node&lt;T&gt; * temp;             if (k&gt;=size||k&lt;0) return NULL;             if (k!=0) temp = getFromIndex(k-1);             else{                     if(head==NULL) return NULL;                     T n = head -&gt; num;                     head = head -&gt; next;                     size--;                     return n;             }             if(temp==NULL) return NULL;             T n = temp -&gt; next -&gt; num;                          temp -&gt; next = temp -&gt; next -&gt; next;             size--;             return n;         }          // å–å¾—å¤§å°          int getSize() {             return size;         }      // ä¸å…¬é–‹çš„      private:         Node&lt;T&gt; * head;         Node&lt;T&gt; * tail;         int size;          // é€™é‚Šä¹‹æ‰€ä»¥æ”¾åœ¨private æ˜¯ç‚ºäº†é˜²æ­¢æœ‰äººé€éæ­¤æ–¹æ³•ç ´å£LinkedList          // æ­¤æ–¹æ³•å–®ç´”å°±æ˜¯å°‡ç¬¬iå€‹Nodeå›å‚³          Node&lt;T&gt; * getFromIndex(int i) {             if(i==0) return head;             if(i&gt;=size) return NULL;             Node&lt;T&gt; * temp = head;             for(int j = 0 ; j &lt; i ; j++) {                 temp = temp -&gt; next;             }              return temp;         } };  int main(){         LinkedList&lt;int&gt; a;        a.push(12);        a.push(14);        a.push(16);        a.removeFromIndex(2); // åˆªé™¤ç¬¬ä¸‰å€‹ç¯€é» }",
        "output": "Did you ever check the correctness of your code?  ä¾‹å¦‚ï¼šT n = temp -&gt; next -&gt; num; åœ¨é€™ä¹‹å‰ä¸ç”¨æª¢æ¸¬temp-&gt;next!=NULLå—ï¼Ÿ"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: - æ¯”è¼ƒptrX = ptrX-&gt;nextå’ŒptrX-&gt;next = ptrXçš„å·®ç•°ã€‚  å› ç‚ºç­‰è™Ÿçš„é‹ç®—å„ªå…ˆé †åºæ˜¯ ç”±å³è‡³å·¦ ï¼Œæ‰€ä»¥å³é‚Šåšå®Œçš„å€¼æœƒè¤‡è£½çµ¦å·¦é‚Šçš„è®Šæ•¸ï¼Œå› æ­¤(çœ‹ä¸‹é¢èªªæ˜)  (1) ptrX = ptrX-&gt;next  ptrX-&gt;nextæ‰€æŒ‡å‘çš„ä½ç½®æœƒè¤‡è£½çµ¦ptrX  #è¨»:ç´…å­—ç‚ºé‹ç®—å®Œçš„çµæœ  (2) ptrX-&gt;next = ptrX  ptrXæ‰€æŒ‡å‘çš„ä½ç½®æœƒè¤‡è£½çµ¦ptrX-&gt;next  #è¨»:ç´…å­—ç‚ºé‹ç®—å®Œçš„çµæœ  çµè«–: å·¦å¼æŒ‡å‘ç¬¬äºŒå€‹ç¯€é»ï¼›å³å¼æŒ‡å‘åŸæœ¬çš„ä½ç½®(ç¬¬ä¸€å€‹ç¯€é»)ï¼Œå…©è€…ä¸åŒã€‚  (å‡è¨­ptrXæŒ‡å‘ç¬¬ä¸€å€‹ç¯€é»æ™‚)",
        "output": "ğŸ‘ğŸ» Nice. Good. è®šè®š èªªæ˜å¾—å¾ˆæ¸…æ¥š,è®š!"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: å‡è¨­ä¸€éˆçµä¸²åˆ—ç‚ºä¸‹åœ–æ‰€ç¤º    åœ¨ç¨‹å¼ä¸­ï¼Œä¸€å€‹ç­‰è™Ÿæ˜¯ç”¨ä¾†å°‡å³é‚Šçš„å€¼å­˜æ”¾åˆ°å·¦é‚Šçš„è®Šæ•¸ï¼Œæ‰€ä»¥ptrX = ptrX-&gt;nextç°¡å–®ä¾†èªªå°±æ˜¯è®“ptrXæ“æœ‰èˆ‡ptrX-&gt;nextç›¸åŒçš„å½¢å¼ï¼Œè®“ptrXæŒ‡å‘èˆ‡ptrX-&gt;nextç›¸åŒçš„ç¯€é»ï¼Œå¦‚ä¸‹åœ–æ‰€ç¤º    è€ŒptrX-&gt;next = ptrXå°±æ˜¯åéä¾†ï¼Œè®“ptrX-&gt;nextæŒ‡å‘èˆ‡ptrXç›¸åŒçš„ç¯€é»ï¼Œä½†ç”±æ–¼ptrXæ‰€æŒ‡å‘çš„ç¯€é»å°±æ˜¯ptrX-&gt;nextï¼Œæ‰€ä»¥ptrX-&gt;nextæœ€å¾ŒæœƒæŒ‡å‘è‡ªå·±ï¼Œå¦‚ä¸‹åœ–æ‰€ç¤º",
        "output": "OK OK. ğŸ‘"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: ptrX = ptrX -&gt; next  æ„æ€æ˜¯å°‡ptrXçš„ç®­é ­æ–¹å‘æŒ‡å‘ptrX -&gt; nextæŒ‡å‘çš„æ–¹å‘  ptrX -&gt; next = ptrX  æ„æ€æ˜¯å°‡ptrX -&gt; nextçš„ç®­é ­æ–¹å‘æŒ‡å‘ptrXæŒ‡å‘çš„æ–¹å‘",
        "output": "å¥½æ£’! åœ–ç•«å¾—è »æ¸…æ¥šçš„ è®š è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: (1) ptrX = ptrX-&gt;next       ptrXæœƒæŒ‡å‘ptrX-&gt;nextæ‰€æŒ‡å‘çš„ä½ç½®    (2) ptrX-&gt;next = ptrX       ptrX-&gt;nextæœƒæŒ‡å‘ptrXæ‰€æŒ‡å‘çš„ä½ç½®    *ä»¥ä¸Šå…©å¼µåœ–çš„ç´…è‰²ç®­é ­æ˜¯å¾Œä¾†æ‰€æŒ‡å‘çš„æ–¹å‘",
        "output": "æ‰‹ç¹ªæ’ç•«ä½³~è®š è®š è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: 1. å–®å‘éˆçµä¸²åˆ—è¦æ‰¾ä¸€å€‹ç¯€é»çš„ä¸Šä¸€å€‹ç¯€é»çš„è©±ï¼Œå¿…é ˆå¾é ­é–‹å§‹æ‰¾ï¼Œä½†é›™å‘éˆçµä¸²åˆ—æœ‰å…©å€‹æŒ‡æ¨™ç¯€é»ï¼Œåœ¨è™•ç†åŠ å…¥æˆ–åˆªé™¤ç¯€é»å‹•ä½œæ™‚ï¼Œé€Ÿåº¦æ¯”è¼ƒå¿«ã€‚  2.è‹¥é›™å‘éˆçµä¸²åˆ—æœ‰ä»»ä¸€ç«¯çš„æŒ‡æ¨™é€£çµéŒ¯èª¤æˆ–è„«è½ï¼Œå®ƒå¯ä»¥å¿«é€Ÿé€²è¡Œä¿®è£œéŒ¯èª¤æˆ–è„«è½çš„é€£çµç¯€é»ã€‚  3.å¯é›™å‘è®€å–ç¯€é»",
        "output": "è®š è®š è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: a b + c * d e + f * + w z + *  postfix-&gt;infix  (a+b)c*(d+e)f*+(w+z)*  ((a+b)*c)((d+e)*f)+(w+z)*  (((a+b)*c)+ ((d+e)*f))(w+z)*  (((a+b)*c)+ ((d+e)*f))*(w+z)  infix-&gt;prefixt  (((+ab)*c)+ ((+de)*f))*(+wz)  ((*+abc)+(*+def))*(+wz)  (+*+abc*+def)*(+wz)  *+*+abc*+def+wz  a b + c * d e + f * + w z + *  (a+b)c*(d+e)f*+(w+z)*  ((a+b)*c)((d+e)*f)+(w+z)*  (((a+b)*c)+ ((d+e)*f))(w+z)*  (((a+b)*c)+ ((d+e)*f))*(w+z)  (((+ab)*c)+ ((+de)*f))*(+wz)  ((*+abc)+(*+def))*(+wz)  (+*+abc*+def)*(+wz)  *+*+abc*+def+wz",
        "output": "å¤ªæœƒäº†å§ good! ğŸ‘ğŸ»"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: æ¯”è¼ƒptrX = ptrX-&gt;nextå’ŒptrX-&gt;next = ptrXçš„å·®ç•°   \t \t\t \t\t\t  \t\t\t \t\t\tptrX = ptrX -&gt; next \t\t\t \t\t \t\t \t\t\t \t\t\tèªªæ˜ \t\t\t \t\t\t \t\t\tå°‡ptrX -&gt; nextæ­¤é …å‹•ä½œçµ¦äºˆptrX \t\t\t \t\t \t\t \t\t\t \t\t\tåœ–ç‰‡ \t\t\t \t\t\t \t\t\t \t\t\t \t\t \t    \t \t\t \t\t\t  \t\t\t \t\t\tptrX -&gt; next = ptrX \t\t\t \t\t \t\t \t\t\t \t\t\tèªªæ˜ \t\t\t \t\t\t \t\t\tå°‡ptrXæ­¤é …å‹•ä½œçµ¦äºˆptrX -&gt; next \t\t\t \t\t \t\t \t\t\t \t\t\tåœ–ç‰‡ \t\t\t \t\t\t \t\t\t \t\t\t \t\t \t   çµè«–:  ç”±æ–¼ç­‰è™Ÿé‹ç®—é †åºç”±å³è‡³å·¦ï¼Œå› æ­¤ptrX = ptrX-&gt;nextå’ŒptrX-&gt;next = ptrXç”¢ç”Ÿå·®ç•°ã€‚",
        "output": "è®š! nice æ£’ï¼"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: Call by address(å‚³å€)ï¼šç°¡å–®ä¾†èªªå°±æ˜¯ç›´æ¥å‘¼å«ä»–çš„è¨˜æ†¶é«”ä½ç½®é€²è¡Œä¿®æ”¹ã€‚  å°‡åƒæ•¸ä»¥è¨˜æ†¶é«”ä½ç½®çš„æ–¹å¼å‚³åˆ°å‘¼å«æ­¤åƒæ•¸çš„functionï¼Œæ­¤functionéœ€è¦æœ‰ä¸€å€‹æŒ‡æ¨™ä¾†æŒ‡åˆ°é€™å€‹åƒæ•¸çš„è¨˜æ†¶é«”ä½ç½®ï¼Œæ‰€ä»¥ä¹Ÿæœ‰äººæŠŠCall by addressç¨±ä½œCall by value of pointerã€‚ å› ç‚ºä¸»ç¨‹å¼å’Œè¢«å‘¼å«çš„functionæ˜¯ä½¿ç”¨ç›¸åŒè¨˜æ†¶é«”ä½ç½®çš„å…§å®¹ï¼Œæ‰€ä»¥ç•¶functionçš„å…§å®¹æ›´æ”¹æ™‚ï¼ŒåŒæ™‚ä¹Ÿæœƒå½±éŸ¿åˆ°ä¸»ç¨‹å¼çš„æ•¸å€¼ï¼Œå‚³æŒ‡æ¨™ä»ç„¶æ˜¯call by value åªæ˜¯é‚£å€‹valueæ˜¯æŒ‡æ¨™æœ¬èº«ï¼Œè¤‡è£½çš„å…§å®¹ä¹Ÿæ˜¯æŒ‡æ¨™æœ¬èº«ï¼Œåªä¸éé‚£å€‹valueå‰›å¥½å°±æ˜¯addressè€Œå·²ã€‚  -   Call by value(å‚³å€¼)ï¼šåƒæ•¸ä»¥æ•¸å€¼æ–¹å¼å‚³éã€‚  -  Call by reference(å‚³åƒè€ƒ)ï¼šå› ç‚ºcall by addressçš„å…§å®¹ç‚ºæŒ‡å‘çš„ä½ç½®ï¼Œæ‰€ä»¥å‚³å€çš„æŒ‡æ¨™æœ¬èº«ç„¶ä»ç„¶æœ‰è¨˜æ†¶é«”ä½ç½®ï¼Œä½†æ˜¯å‚³åƒè€ƒæ˜¯ä¸æœƒæœ‰çš„ã€‚ä¹Ÿå› æ­¤C++çš„Call by referenceæœ¬è³ªä¸Šä¸æ˜¯call by valueï¼Œé€™ä¹Ÿæ˜¯å’Œcall by addressä¹‹é–“çš„å·®åˆ¥ã€‚  #############",
        "output": "ğŸ‘ è®š Good! ğŸ‘ğŸ»"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;  struct Happy{     int num = 0;     Happy*next; };  int main(){     Happy *head = new Happy;     Happy *current = head;     Happy *tail = head;      //äº”å€‹ç¯€é»index:01234     int i = 0;      while( i &lt; 5 ){         tail-&gt;num = i;         tail = tail-&gt;next;         i++;     }      current = current-&gt;next; //è®“currentæŒ‡å‘ä¸€è™Ÿ(ç¬¬äºŒå€‹ç¯€é»)      current-&gt;next = current-&gt;next-&gt;next; // äºŒè™ŸæŒ‡å‘çš„æ±è¥¿çµ¦ä¸€è™ŸæŒ‡      while(head!=tail){  //å°å‡ºç¯€é»index:0134         cout&lt;&lt;head-&gt;num;         head= head-&gt;next;     } }",
        "output": "Good! ğŸ‘ğŸ» è®š æœ¬èª²ç¨‹å‹¿ä½¿ç”¨#include &lt;bits/stdc++.h&gt;"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;  int main() {     list&lt;int&gt; intlist;     for(int i=0;i&lt;5;i++)         intlist.push_back(i);     for(auto i:intlist) //å°å‡ºåˆå§‹é™£åˆ—         cout&lt;&lt;i&lt;&lt;   ;     cout&lt;&lt;endl;      intlist.erase(next(intlist.begin(),2));      for(auto i:intlist) //å°å‡ºä¿®æ”¹å¾Œé™£åˆ—         cout&lt;&lt;i&lt;&lt;   ; }  è¼¸å‡º  0 1 2 3 4  0 1 3 4",
        "output": "å¥½æ£’ æœ¬èª²ç¨‹å‹¿ä½¿ç”¨#include &lt;bits/stdc++.h&gt;  æœ¬èª²ç¨‹å‹¿ä½¿ç”¨auto  ä¸‹æ¬¡è¦‹åˆ°é€™é¡ç¨‹å¼ç¢¼å°‡é€•è‡ªåˆªé™¤ï¼"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;  int main() {     list&lt;int&gt; AList;     for(int i=0;i&lt;10;i++)         AList.push_back(i);     cout &lt;&lt;  Before:  ; //å°å‡ºåˆå§‹é™£åˆ—     for(auto i:AList){         cout&lt;&lt;i&lt;&lt;   ;     }     cout&lt;&lt;endl;      list&lt;int&gt;::iterator it = AList.begin(); // åˆªé™¤ç¬¬ä¸‰å€‹     advance(it,2);     AList.erase(it);      cout &lt;&lt;  After:  ; //å°å‡ºä¿®æ”¹å¾Œé™£åˆ—     for(auto i:AList){         cout&lt;&lt;i&lt;&lt;   ;     } }",
        "output": "æœ¬èª²ç¨‹å‹¿ä½¿ç”¨#include &lt;bits/stdc++.h&gt;  æœ¬èª²ç¨‹å‹¿ä½¿ç”¨auto  ä¸‹æ¬¡è¦‹åˆ°é€™é¡ç¨‹å¼ç¢¼å°‡é€•è‡ªåˆªé™¤ï¼"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: ",
        "output": "ğŸ‘"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: é€™é¡Œä¸»è¦æ˜¯åˆªæ‰ç¬¬ä¸‰å€‹ç¯€é» è‡³æ–¼æ€éº¼åšå‘¢? å°±æ˜¯å…ˆå–å¾—ç¬¬äºŒå€‹ç¯€é» å†è®“ç¬¬äºŒå€‹ç¯€é»çš„nextè¨­æˆç¬¬å››å€‹ç¯€é»   #include&lt;bits/stdc++.h&gt; // é€™çœŸçš„æ˜¯ä¸å¥½çš„ç¤ºç¯„ ä¸è¦äº‚ä½¿ç”¨ using namespace std; // é€™ä¹Ÿæ˜¯å€‹éå¸¸ä¸å¥½çš„ç¤ºç¯„ // Node // åˆ©ç”¨æ³›å‹å¯¦ä½œ template &lt;typename T&gt; struct Node {     T num; // è³‡æ–™     Node * next; };  // åˆ©ç”¨æ³›å‹å¯¦ä½œLinkedList // æ®˜ç¼ºçš„LinkedList, ä¸éå¯ä»¥æ‡‰ä»˜é€™é¡Œ template &lt;typename T&gt; class LinkedList {     public:         // å»ºæ§‹å­         // åˆå§‹åŒ–è³‡æ–™         LinkedList() {             head = NULL;             tail = NULL;             size = 0;         }          // æŠŠè³‡æ–™æ”¾é€²å»         void push(T data) {             // å¦‚æœè£¡é¢ç©ºç©ºçš„             if(size==0) {                 head = new Node&lt;T&gt;; // è®“headè®Šæˆæ–°çš„Node                 head -&gt; num = data; // æŠŠè³‡æ–™æ”¾é€²å»                 head -&gt; next = NULL; // æŒ‡å®šheadçš„nextæ˜¯null                 size++; // è®“size++                 tail = head;// è®“tailè®Šæˆhead                 return; // return å›å» é¿å…é€²å…¥ä¸‹ä¸€è¡Œ             }              // è¦æ˜¯ä¸æ˜¯ç©ºçš„è©±             tail -&gt; next = new Node&lt;T&gt;; // å…ˆè®“tailçš„ä¸‹ä¸€å€‹è®Šæˆæ–°çš„Node             tail = tail -&gt; next; // æŠŠtail ç§»åˆ°ä¸‹ä¸€å±¤             tail -&gt; num = data;// æŠŠè³‡æ–™æ”¾é€²å»             tail -&gt; next = NULL; // tailçš„ä¸‹ä¸€å€‹æŒ‡å®šç‚ºNULL             size++;// sizeå¢åŠ              return;// return å›å» å¯åŠ å¯ä¸åŠ          }          // å–®ç´”çš„è¤‡è£½LinkedList         // é€™é‚Šæ˜¯ç”¢ç”Ÿä¸€å€‹æ–°çš„LinkedList è€Œä¸æ˜¯æŠŠåŸæœ¬çš„returnå›å»         // å› ç‚ºå¦‚æœæ˜¯æŠŠåŸæœ¬çš„returnå›å»ï¼Œæœƒå°è‡´è³‡æ–™æœƒè¢«äº’ç›¸å¼•éŸ¿         LinkedList copy() {             LinkedList toReturn; // æº–å‚™å›å‚³å›å»çš„è³‡æ–™             Node&lt;T&gt; * temp = head; // æŒ‡æ¨™ ç”¨ä¾†èµ°è¨ªæ•´å€‹LinkedList             while(temp!=NULL) {                 toReturn.push(temp-&gt;num); // é€éæ–¹æ³•ä¸€ç›´å»pushè³‡æ–™                 temp = temp -&gt; next;             }             return toReturn; // return          }          // é€é index å»å–å¾—è³‡æ–™         T getDataFromIndex(int k) {             Node&lt;T&gt; * temp = getFromIndex(k);             return temp -&gt; num;         }          // é€éindex ç§»é™¤è³‡æ–™ ä¸¦ä¸”å°‡è³‡æ–™å›å‚³          T removeFromIndex(int k) {             Node&lt;T&gt; * temp;             if (k&gt;=size||k&lt;0) return NULL;             if (k!=0) temp = getFromIndex(k-1);             else{                     if(head==NULL) return NULL;                     T n = head -&gt; num;                     head = head -&gt; next;                     size--;                     return n;             }             if(temp==NULL) return NULL;             T n = temp -&gt; next -&gt; num;                          temp -&gt; next = temp -&gt; next -&gt; next;             size--;             return n;         }          // å–å¾—å¤§å°          int getSize() {             return size;         }      // ä¸å…¬é–‹çš„      private:         Node&lt;T&gt; * head;         Node&lt;T&gt; * tail;         int size;          // é€™é‚Šä¹‹æ‰€ä»¥æ”¾åœ¨private æ˜¯ç‚ºäº†é˜²æ­¢æœ‰äººé€éæ­¤æ–¹æ³•ç ´å£LinkedList          // æ­¤æ–¹æ³•å–®ç´”å°±æ˜¯å°‡ç¬¬iå€‹Nodeå›å‚³          Node&lt;T&gt; * getFromIndex(int i) {             if(i==0) return head;             if(i&gt;=size) return NULL;             Node&lt;T&gt; * temp = head;             for(int j = 0 ; j &lt; i ; j++) {                 temp = temp -&gt; next;             }              return temp;         } };  int main(){         LinkedList&lt;int&gt; a;        a.push(12);        a.push(14);        a.push(16);        a.removeFromIndex(2); // åˆªé™¤ç¬¬ä¸‰å€‹ç¯€é» }",
        "output": "Did you ever check the correctness of your code?  ä¾‹å¦‚ï¼šT n = temp -&gt; next -&gt; num; åœ¨é€™ä¹‹å‰ä¸ç”¨æª¢æ¸¬temp-&gt;next!=NULLå—ï¼Ÿ"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: - æ¯”è¼ƒptrX = ptrX-&gt;nextå’ŒptrX-&gt;next = ptrXçš„å·®ç•°ã€‚  å› ç‚ºç­‰è™Ÿçš„é‹ç®—å„ªå…ˆé †åºæ˜¯ ç”±å³è‡³å·¦ ï¼Œæ‰€ä»¥å³é‚Šåšå®Œçš„å€¼æœƒè¤‡è£½çµ¦å·¦é‚Šçš„è®Šæ•¸ï¼Œå› æ­¤(çœ‹ä¸‹é¢èªªæ˜)  (1) ptrX = ptrX-&gt;next  ptrX-&gt;nextæ‰€æŒ‡å‘çš„ä½ç½®æœƒè¤‡è£½çµ¦ptrX  #è¨»:ç´…å­—ç‚ºé‹ç®—å®Œçš„çµæœ  (2) ptrX-&gt;next = ptrX  ptrXæ‰€æŒ‡å‘çš„ä½ç½®æœƒè¤‡è£½çµ¦ptrX-&gt;next  #è¨»:ç´…å­—ç‚ºé‹ç®—å®Œçš„çµæœ  çµè«–: å·¦å¼æŒ‡å‘ç¬¬äºŒå€‹ç¯€é»ï¼›å³å¼æŒ‡å‘åŸæœ¬çš„ä½ç½®(ç¬¬ä¸€å€‹ç¯€é»)ï¼Œå…©è€…ä¸åŒã€‚  (å‡è¨­ptrXæŒ‡å‘ç¬¬ä¸€å€‹ç¯€é»æ™‚)",
        "output": "ğŸ‘ğŸ» Nice. Good. è®šè®š èªªæ˜å¾—å¾ˆæ¸…æ¥š,è®š!"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: å‡è¨­ä¸€éˆçµä¸²åˆ—ç‚ºä¸‹åœ–æ‰€ç¤º    åœ¨ç¨‹å¼ä¸­ï¼Œä¸€å€‹ç­‰è™Ÿæ˜¯ç”¨ä¾†å°‡å³é‚Šçš„å€¼å­˜æ”¾åˆ°å·¦é‚Šçš„è®Šæ•¸ï¼Œæ‰€ä»¥ptrX = ptrX-&gt;nextç°¡å–®ä¾†èªªå°±æ˜¯è®“ptrXæ“æœ‰èˆ‡ptrX-&gt;nextç›¸åŒçš„å½¢å¼ï¼Œè®“ptrXæŒ‡å‘èˆ‡ptrX-&gt;nextç›¸åŒçš„ç¯€é»ï¼Œå¦‚ä¸‹åœ–æ‰€ç¤º    è€ŒptrX-&gt;next = ptrXå°±æ˜¯åéä¾†ï¼Œè®“ptrX-&gt;nextæŒ‡å‘èˆ‡ptrXç›¸åŒçš„ç¯€é»ï¼Œä½†ç”±æ–¼ptrXæ‰€æŒ‡å‘çš„ç¯€é»å°±æ˜¯ptrX-&gt;nextï¼Œæ‰€ä»¥ptrX-&gt;nextæœ€å¾ŒæœƒæŒ‡å‘è‡ªå·±ï¼Œå¦‚ä¸‹åœ–æ‰€ç¤º",
        "output": "OK OK. ğŸ‘"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: ptrX = ptrX -&gt; next  æ„æ€æ˜¯å°‡ptrXçš„ç®­é ­æ–¹å‘æŒ‡å‘ptrX -&gt; nextæŒ‡å‘çš„æ–¹å‘  ptrX -&gt; next = ptrX  æ„æ€æ˜¯å°‡ptrX -&gt; nextçš„ç®­é ­æ–¹å‘æŒ‡å‘ptrXæŒ‡å‘çš„æ–¹å‘",
        "output": "å¥½æ£’! åœ–ç•«å¾—è »æ¸…æ¥šçš„ è®š è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: (1) ptrX = ptrX-&gt;next       ptrXæœƒæŒ‡å‘ptrX-&gt;nextæ‰€æŒ‡å‘çš„ä½ç½®    (2) ptrX-&gt;next = ptrX       ptrX-&gt;nextæœƒæŒ‡å‘ptrXæ‰€æŒ‡å‘çš„ä½ç½®    *ä»¥ä¸Šå…©å¼µåœ–çš„ç´…è‰²ç®­é ­æ˜¯å¾Œä¾†æ‰€æŒ‡å‘çš„æ–¹å‘",
        "output": "æ‰‹ç¹ªæ’ç•«ä½³~è®š è®š è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: 1. å–®å‘éˆçµä¸²åˆ—è¦æ‰¾ä¸€å€‹ç¯€é»çš„ä¸Šä¸€å€‹ç¯€é»çš„è©±ï¼Œå¿…é ˆå¾é ­é–‹å§‹æ‰¾ï¼Œä½†é›™å‘éˆçµä¸²åˆ—æœ‰å…©å€‹æŒ‡æ¨™ç¯€é»ï¼Œåœ¨è™•ç†åŠ å…¥æˆ–åˆªé™¤ç¯€é»å‹•ä½œæ™‚ï¼Œé€Ÿåº¦æ¯”è¼ƒå¿«ã€‚  2.è‹¥é›™å‘éˆçµä¸²åˆ—æœ‰ä»»ä¸€ç«¯çš„æŒ‡æ¨™é€£çµéŒ¯èª¤æˆ–è„«è½ï¼Œå®ƒå¯ä»¥å¿«é€Ÿé€²è¡Œä¿®è£œéŒ¯èª¤æˆ–è„«è½çš„é€£çµç¯€é»ã€‚  3.å¯é›™å‘è®€å–ç¯€é»",
        "output": "è®š è®š è®š"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: a b + c * d e + f * + w z + *  postfix-&gt;infix  (a+b)c*(d+e)f*+(w+z)*  ((a+b)*c)((d+e)*f)+(w+z)*  (((a+b)*c)+ ((d+e)*f))(w+z)*  (((a+b)*c)+ ((d+e)*f))*(w+z)  infix-&gt;prefixt  (((+ab)*c)+ ((+de)*f))*(+wz)  ((*+abc)+(*+def))*(+wz)  (+*+abc*+def)*(+wz)  *+*+abc*+def+wz  a b + c * d e + f * + w z + *  (a+b)c*(d+e)f*+(w+z)*  ((a+b)*c)((d+e)*f)+(w+z)*  (((a+b)*c)+ ((d+e)*f))(w+z)*  (((a+b)*c)+ ((d+e)*f))*(w+z)  (((+ab)*c)+ ((+de)*f))*(+wz)  ((*+abc)+(*+def))*(+wz)  (+*+abc*+def)*(+wz)  *+*+abc*+def+wz",
        "output": "å¤ªæœƒäº†å§ good! ğŸ‘ğŸ»"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: æ¯”è¼ƒptrX = ptrX-&gt;nextå’ŒptrX-&gt;next = ptrXçš„å·®ç•°   \t \t\t \t\t\t  \t\t\t \t\t\tptrX = ptrX -&gt; next \t\t\t \t\t \t\t \t\t\t \t\t\tèªªæ˜ \t\t\t \t\t\t \t\t\tå°‡ptrX -&gt; nextæ­¤é …å‹•ä½œçµ¦äºˆptrX \t\t\t \t\t \t\t \t\t\t \t\t\tåœ–ç‰‡ \t\t\t \t\t\t \t\t\t \t\t\t \t\t \t    \t \t\t \t\t\t  \t\t\t \t\t\tptrX -&gt; next = ptrX \t\t\t \t\t \t\t \t\t\t \t\t\tèªªæ˜ \t\t\t \t\t\t \t\t\tå°‡ptrXæ­¤é …å‹•ä½œçµ¦äºˆptrX -&gt; next \t\t\t \t\t \t\t \t\t\t \t\t\tåœ–ç‰‡ \t\t\t \t\t\t \t\t\t \t\t\t \t\t \t   çµè«–:  ç”±æ–¼ç­‰è™Ÿé‹ç®—é †åºç”±å³è‡³å·¦ï¼Œå› æ­¤ptrX = ptrX-&gt;nextå’ŒptrX-&gt;next = ptrXç”¢ç”Ÿå·®ç•°ã€‚",
        "output": "è®š! nice æ£’ï¼"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: Call by address(å‚³å€)ï¼šç°¡å–®ä¾†èªªå°±æ˜¯ç›´æ¥å‘¼å«ä»–çš„è¨˜æ†¶é«”ä½ç½®é€²è¡Œä¿®æ”¹ã€‚  å°‡åƒæ•¸ä»¥è¨˜æ†¶é«”ä½ç½®çš„æ–¹å¼å‚³åˆ°å‘¼å«æ­¤åƒæ•¸çš„functionï¼Œæ­¤functionéœ€è¦æœ‰ä¸€å€‹æŒ‡æ¨™ä¾†æŒ‡åˆ°é€™å€‹åƒæ•¸çš„è¨˜æ†¶é«”ä½ç½®ï¼Œæ‰€ä»¥ä¹Ÿæœ‰äººæŠŠCall by addressç¨±ä½œCall by value of pointerã€‚ å› ç‚ºä¸»ç¨‹å¼å’Œè¢«å‘¼å«çš„functionæ˜¯ä½¿ç”¨ç›¸åŒè¨˜æ†¶é«”ä½ç½®çš„å…§å®¹ï¼Œæ‰€ä»¥ç•¶functionçš„å…§å®¹æ›´æ”¹æ™‚ï¼ŒåŒæ™‚ä¹Ÿæœƒå½±éŸ¿åˆ°ä¸»ç¨‹å¼çš„æ•¸å€¼ï¼Œå‚³æŒ‡æ¨™ä»ç„¶æ˜¯call by value åªæ˜¯é‚£å€‹valueæ˜¯æŒ‡æ¨™æœ¬èº«ï¼Œè¤‡è£½çš„å…§å®¹ä¹Ÿæ˜¯æŒ‡æ¨™æœ¬èº«ï¼Œåªä¸éé‚£å€‹valueå‰›å¥½å°±æ˜¯addressè€Œå·²ã€‚  -   Call by value(å‚³å€¼)ï¼šåƒæ•¸ä»¥æ•¸å€¼æ–¹å¼å‚³éã€‚  -  Call by reference(å‚³åƒè€ƒ)ï¼šå› ç‚ºcall by addressçš„å…§å®¹ç‚ºæŒ‡å‘çš„ä½ç½®ï¼Œæ‰€ä»¥å‚³å€çš„æŒ‡æ¨™æœ¬èº«ç„¶ä»ç„¶æœ‰è¨˜æ†¶é«”ä½ç½®ï¼Œä½†æ˜¯å‚³åƒè€ƒæ˜¯ä¸æœƒæœ‰çš„ã€‚ä¹Ÿå› æ­¤C++çš„Call by referenceæœ¬è³ªä¸Šä¸æ˜¯call by valueï¼Œé€™ä¹Ÿæ˜¯å’Œcall by addressä¹‹é–“çš„å·®åˆ¥ã€‚  #############",
        "output": "ğŸ‘ è®š Good! ğŸ‘ğŸ»"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;  struct Happy{     int num = 0;     Happy*next; };  int main(){     Happy *head = new Happy;     Happy *current = head;     Happy *tail = head;      //äº”å€‹ç¯€é»index:01234     int i = 0;      while( i &lt; 5 ){         tail-&gt;num = i;         tail = tail-&gt;next;         i++;     }      current = current-&gt;next; //è®“currentæŒ‡å‘ä¸€è™Ÿ(ç¬¬äºŒå€‹ç¯€é»)      current-&gt;next = current-&gt;next-&gt;next; // äºŒè™ŸæŒ‡å‘çš„æ±è¥¿çµ¦ä¸€è™ŸæŒ‡      while(head!=tail){  //å°å‡ºç¯€é»index:0134         cout&lt;&lt;head-&gt;num;         head= head-&gt;next;     } }",
        "output": "Good! ğŸ‘ğŸ» è®š æœ¬èª²ç¨‹å‹¿ä½¿ç”¨#include &lt;bits/stdc++.h&gt;"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;  int main() {     list&lt;int&gt; intlist;     for(int i=0;i&lt;5;i++)         intlist.push_back(i);     for(auto i:intlist) //å°å‡ºåˆå§‹é™£åˆ—         cout&lt;&lt;i&lt;&lt;   ;     cout&lt;&lt;endl;      intlist.erase(next(intlist.begin(),2));      for(auto i:intlist) //å°å‡ºä¿®æ”¹å¾Œé™£åˆ—         cout&lt;&lt;i&lt;&lt;   ; }  è¼¸å‡º  0 1 2 3 4  0 1 3 4",
        "output": "å¥½æ£’ æœ¬èª²ç¨‹å‹¿ä½¿ç”¨#include &lt;bits/stdc++.h&gt;  æœ¬èª²ç¨‹å‹¿ä½¿ç”¨auto  ä¸‹æ¬¡è¦‹åˆ°é€™é¡ç¨‹å¼ç¢¼å°‡é€•è‡ªåˆªé™¤ï¼"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: #include &lt;bits/stdc++.h&gt; using namespace std;  int main() {     list&lt;int&gt; AList;     for(int i=0;i&lt;10;i++)         AList.push_back(i);     cout &lt;&lt;  Before:  ; //å°å‡ºåˆå§‹é™£åˆ—     for(auto i:AList){         cout&lt;&lt;i&lt;&lt;   ;     }     cout&lt;&lt;endl;      list&lt;int&gt;::iterator it = AList.begin(); // åˆªé™¤ç¬¬ä¸‰å€‹     advance(it,2);     AList.erase(it);      cout &lt;&lt;  After:  ; //å°å‡ºä¿®æ”¹å¾Œé™£åˆ—     for(auto i:AList){         cout&lt;&lt;i&lt;&lt;   ;     } }",
        "output": "æœ¬èª²ç¨‹å‹¿ä½¿ç”¨#include &lt;bits/stdc++.h&gt;  æœ¬èª²ç¨‹å‹¿ä½¿ç”¨auto  ä¸‹æ¬¡è¦‹åˆ°é€™é¡ç¨‹å¼ç¢¼å°‡é€•è‡ªåˆªé™¤ï¼"
    },
    {
        "instruction": "è«‹æ ¹æ“šä»¥ä¸‹ç­”æ¡ˆåšå‡ºè©•è«–",
        "input": "é¡Œç›®: \nç­”æ¡ˆ: ",
        "output": "ğŸ‘"
    }
]