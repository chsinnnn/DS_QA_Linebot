{
    "data": {
        "@version": "3.0",
        "@time": "2024-07-19 08:53:34",
        "@type": "post",
        "@filename": "b000000003.xml",
        "open_time": "0000-00-00",
        "close_time": "0000-00-00",
        "lang_name": "Big5",
        "board_id": "1001296418",
        "node": "000000003",
        "site": "1000110001",
        "pt": "2023-09-29 12:12:56",
        "poster": "11127139",
        "realname": "陳　恩",
        "email": "a04182596@gmail.com",
        "homepage": null,
        "subject": "107",
        "content": "<p>作業一採用什麼資料結構儲存讀入資料，須說明原因。<br />\r\n<br />\r\n作業中會讀入X,Y及X*Y大小的字符迷宮，由於輸入資料是具有座標性的地圖，因此可以將字符迷宮儲存為Y列，每一列存X個字符的一個二維陣列，每個位置具有不同的性質如&#39;O&#39;、&#39;E&#39;、&#39;G&#39;等等，所以使用的是字元的二維陣列。</p>\r\n\r\n<p><br />\r\n由於程式運行時，我們只有在讀入地圖的文字檔時才能得知需要儲存的地圖實際大小為何 (X, Y)，因此靜態的二維陣列就不是最佳選擇了。若宣告的太小會導致程式無法運行，太大又會導致記憶體的浪費。<br />\r\n<br />\r\n我選擇的是定義一個迷宮的類別，其中包含了地圖及一些運算方法對地圖進行存取、改動：<br />\r\n地圖採用的是字元動態二維陣列 ( char** p )進行儲存，在讀入 X, Y後再配置記憶體空間儲存，缺點是沒有方法可以使用，需要手動 new需要的陣列大小的空間以供儲存。除此之外在存取時還要小心索引值超出範圍等等的安全性問題。<br />\r\n因此我在迷宮類別中定義了一些方法檢查座標是否超出範圍，還有複製地圖的運算方法，盡量確保錯誤的產生。</p>\r\n\r\n<p><br />\r\n除此之外也可以使用 Vector &lt;String&gt; 或 String *p = new String[Y] 等等方式實現二維陣列的概念：<br />\r\nVector中有關於out of bounds等等的檢查，可以確保程式在記憶體存取上的安全性，同時string也不需要和字元陣列一樣設定固定的大小，且有很多的方法可以進行使用，使程式碼更簡潔。</p>\r\n\r\n<p>同時，使用字元動態二維陣列作為參數傳遞時是有可能被改動資料的，在使用上需要非常小心。如果使用 Vector &lt;String&gt; 就不必擔心改動原始資料，因為C++的物件資料是採用call by value的方式進行的。除非是物件本身具有指標類型的 data member，否則原則上不太會有竄改資料的問題。</p>",
        "attach": null,
        "rcount": null,
        "rank": null,
        "hit": "51",
        "lang": "1"
    }
}