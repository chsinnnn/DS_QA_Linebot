[
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明傳值呼叫call by value。  答案: 寫出C++程式碼說明傳值呼叫call by value  *與call by reference相比可清楚看出差異，因此以call by reference做對照。   \t \t\t \t\t\t  \t\t\t \t\t\tCall by value \t\t\t \t\t\t \t\t\tcall by reference \t\t\t \t\t \t\t \t\t\t \t\t\t參數值影響 \t\t\t \t\t\t \t\t\t並不會改變所呼叫參數值，因呼叫的只是該變數當時數值，並不是該變數本身 \t\t\t \t\t\t \t\t\t函數內部所做的更動會影響實際參數 \t\t\t \t\t \t\t \t\t\t \t\t\t儲存位置 \t\t\t \t\t\t \t\t\t呼叫的函數和主程式所使用參數的記憶體位置不同 \t\t\t \t\t\t \t\t\t呼叫的函數和主程式所使用參數的記憶體位置相同",
        "output": "評論:Nice. 評論:👍 評論:讚 評論:好讚 評論:讚"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明傳值呼叫call by value。  答案: 當function使用傳值呼叫( call by value )時  即function 只會複製變數的值來做使用，不會影響儲存在原本記憶體中的變數數值  ( 有點像去借朋友課本影印，印完課本還是朋友的，對影本進行剪貼、筆記皆不會影響原來的課本 )  與之相反的call by reference則是將儲存變數的記憶體位置傳給function，使其可以直接對變數進行更動  ( 以上述舉例而言，就像直接在朋友課本上進行剪貼、筆記 )  #include&lt;iostream&gt; using namespace std; void CallByValue( int n ) {     n += 1;     n *= 10; } // CallByValue void CallByReference( int &amp;n ){     n += 1;     n *= 10; } // CallByReference int main(){     int num = 1;     CallByValue(num);     cout &lt;&lt;  CallByValue :   &lt;&lt; num &lt;&lt; endl;     CallByReference(num);     cout &lt;&lt;  CallByReference :   &lt;&lt; num &lt;&lt; endl;     return 0; } // main()  以上程式碼在CallByValue時，輸出為1  在CallByReference時，輸出為20  兩種程式皆將變數進行相同運算  可知當function call by value時 原變數值不會因function內的動作而改變",
        "output": "評論:OK. 評論:寫得蠻完整的 讚 評論:good 評論:good! 評論:好讚"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明傳值呼叫call by value。  答案: call by value(傳值)： 參數以數值方式傳遞，顧名思義把值傳到另一個記憶體位置的值上 在cal by value的情況下，呼叫函數所傳遞的參數以及參數地址皆不會被改變。  call by reference(傳參考)： 把記憶體位置傳到移到另一個記憶體位置上 (可看作同一個物件) 在cal by reference的情況下，呼叫函數所傳遞的參數可以被改變，但參數地址並不會被改變。  #############  # include &lt;iostream&gt; using namespace std;  void TestRef(int &amp; ref) {     ref = ref * 10;     return ; } //TestRef  void TestVal(int val){     val = val * 10;     return; }// TestVal  int main() {          int ref = 10 , val = 10;     cout &lt;&lt;  1st ref&amp;val:   &lt;&lt; ref &lt;&lt;   /   &lt;&lt; val &lt;&lt; endl;          TestRef(ref);     TestVal(val);      cout &lt;&lt;  2nd ref&amp;val:   &lt;&lt; ref &lt;&lt;   /   &lt;&lt; val &lt;&lt; endl;     return 0;      } // main",
        "output": "評論:Good! 評論:👍 評論:good! 評論:good 評論:讚喔"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明同類別兩個方法如何實現多載overloading。  答案: 在C++中，有 Function Overloading 和 Operator Overloading，但此題是要講述 Function Overloading  那什麼是Function Overloading呢? 1.同樣名稱的函數有多種格式，或說多個函數共用一個函數名稱 2.可以定義兩個有相同名稱的函數，但函數簽名 (Signature) 必須不同    那Function Overloading有什麼好處呢?  1. 避免詞窮的好辦法(想想如果命名20幾個Function，但做的事情大同小異) 2. 因為建構子的名稱必須和class name一樣，因此可以產生許多建構子而不會發生錯誤 3. 讓其他開發者能夠更輕鬆的去使用你所寫的API (不用去背或者查詢很多名稱，而是透過帶入不同參數得出想要的結果)  // 用來示範的一個程式  #include&lt;bits/stdc++.h&gt; // 我很抱歉  using namespace std; // 我真的很抱歉   // 用來示範的一個程式  class Student{     public:         // 沒有參數的建構子          Student(){             this -&gt; name =  ABC ;             this -&gt; studentID = 0;         }                  // 具有參數的建構子         // 至於為什麼可以辦到和前面的method name 一樣 是因為有overloading         //           Student(int ID, string name){             this -&gt; name = name;             this -&gt; studentID = ID;         }                  // 取得ID          int getID(){             return studentID;         }                  // 取得名字          string getName(){             return name;         }                  // 下面兩個名字一樣的Function可以同時存在 因為參數不同          void Change(int id){             this -&gt; studentID = id;         }                  // 這樣依然可以存在          void Change(char c){             printf( 笑死\\n );         }                  // 但底下的就不合法了 因為與上面的重複         // 所以在使用overloading的時候還是要小心          /*         void Change(int k){             printf( %d\\n ,k);         }         */                           void Change(int id, string name){             this -&gt; studentID = id;             this -&gt; name = name;         }                  // 注意 這樣是會出錯的         // 雖然return type不同 但帶入的參數相同 因此無法同時存在          /*         int Change(int c){             this -&gt; studentID = id             return 0;         }         */              // 防止其他地方的程式去存取這兩個東西      private:         int studentID;         string name;          };  int main(){     Student a(12, 123 ); // Initialize through Constructor with arguments     Student b; // Initialize through Constructor without arguments     printf( %d\\n ,a.getID()); // 12     printf( %d\\n ,b.getID()); // 0          // 同樣是Change，但隨著帶入的參數不同，而有不同的效果      a.Change(345);     b.Change(87, DEF );            printf( %d\\n ,a.getID()); // 345     printf( %s\\n ,a.getName().c_str()); // 123          printf( %d\\n ,b.getID()); // 87     printf( %s\\n ,b.getName().c_str()); // DEF }  還有一個東西很常被搞混 那就是Override 至於什麼是Override，就先不討論了，有興趣的人可以Google一下 (參考資源:  http://kaiching.org/pydoing/cpp/cpp-overload.html https://openhome.cc/Gossip/CppGossip/OverloadedFunction.html https://notfalse.net/58/overload)",
        "output": "評論:有料 評論:👍 評論:👍 評論:蠻完整的範例及解說，給參考是不錯的習慣。  private data member是作業#2必須做到的，private method則可有可無。"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明同類別兩個方法如何實現多載overloading。  答案: 可以定義相同名稱之函數，但引數必須不同",
        "output": "評論:OK 評論:👍 評論:讚 評論:讚"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明傳值呼叫call by value。  答案: #include &lt;bits/stdc++.h&gt; using namespace std;   vector &lt;int&gt; vec = {1, 2, 3, 4, 5, 6, 7, 8}; int main() {     for(auto i:vec) i=0; //call by value     for(auto i:vec)         cout &lt;&lt; i &lt;&lt;    ;      cout&lt;&lt;endl;     for(auto &amp;i:vec) i=0; //call by reference     for(auto i:vec)         cout &lt;&lt; i &lt;&lt;    ;  }  輸出    可見call bt value是複製新的數來使用，並不會修改到原本的值。",
        "output": "評論:讚 評論:請依題意解釋程式碼。  附註：  1. 本課程作業勿使用 萬能標頭檔 。(理由：清楚認知程式所使用的既有函數)  2. 本課程作業勿使用auto自動變數。(理由：清楚認知程式所使用的變數型別)"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明傳值呼叫call by value。  答案: #include &lt;bits/stdc++.h&gt; using namespace std;  /* 1. Call by value :     main()中的變數值被複製到副函式swap_CallByValue()，     意即使用的新的記憶體位址，不會改動到主函式main()中的值； */  void swap_CallByValue( int value1, int value2 ) {     int temp = value1;     value1 = value2;     value2 = temp;     cout &lt;&lt;  After swapped by using call by value in sub fucntion :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n ; } // swap_CallByValue()  /* 2. Call by address/pointer :     本質上也是一種call by value，只不過此value就是指標，複製的也是指標。     主函式main()傳入位址後，副函式swap_CallByAddress()以指標指向記憶體位址；     由於交換了記憶體位址，因此回到主函式main()後原本的值會交換。 */  void swap_CallByAddress( int *address1, int *address2 ) {     int temp = *address1;     *address1 = *address2;     *address2 = temp; } // swap_CallByAddress()  /* 3. Call by reference :     僅限C++，直接傳入位址去交換，所以回到主函式main()後原本的值也會交換。     由於call by address是用指標指向位址，因此指標本身也具有位址；     而call by reference是直接傳入位址，本身不具位址。 */  void swap_CallByReference( int &amp;reference1, int &amp;reference2 ) {     int temp = reference1;     reference1 = reference2;     reference2 = temp; } // swap_CallByReference()  /* 4. 比較：     【Call by value】：     (1)若使用太多且使用完沒刪掉未使用的記憶體空間，可能會導致記憶體不足而程式崩潰。     (2)由於要複製值，因此效能較差、較慢     (3)不會影響到主函式          【Call by address/pointer】：     (1)由於接收的是記憶體位址，因此在副函式中的任何變動都可能影響到主函式。     (2)也是一種call by value1          【Call by reference】：     (1)僅限C++     (2)會檢查記憶體位置是否合法         ex.             int iVal = 10;             int &amp;refVal = iVal; // 合法             int &amp;refVal; // 非法，未初始化             (error: &lsquo;refVal&rsquo; declared as reference but not initialized)             int &amp;refVal = 0; // 非法，初值必須是物件             (error: cannot bind non-const lvalue reference of type &lsquo;int&amp;&rsquo; to an rvalue of type &lsquo;int&rsquo;)     (3)當作物件的別名(alias)使用          【效能比較】：     Call by reference = Call by address &gt; Call by value */  int main() {     int value1 = 10, value2 = 20;     cout &lt;&lt;  The original values of call by value :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n ;     swap_CallByValue( value1, value2 );     cout &lt;&lt;  After swapped by using call by value in main fucntion :\\nvalue1 is   &lt;&lt; value1 &lt;&lt;   and value2 is   &lt;&lt; value2 &lt;&lt;  \\n\\n ;          int address1 = 30, address2 = 40;     cout &lt;&lt;  The original values of call by address :\\naddress1 is   &lt;&lt; address1 &lt;&lt;   and address2 is   &lt;&lt; address2 &lt;&lt;  \\n ;     swap_CallByAddress( &amp;address1, &amp;address2 );     cout &lt;&lt;  After swapped by using call by address :\\naddress1 is   &lt;&lt; address1 &lt;&lt;   and address2 is   &lt;&lt; address2 &lt;&lt;  \\n\\n ;          int reference1 = 50, reference2 = 60;     cout &lt;&lt;  The original values of call by reference :\\nreference1 is   &lt;&lt; reference1 &lt;&lt;   and reference2 is   &lt;&lt; reference2 &lt;&lt;  \\n ;     swap_CallByReference( reference1, reference2 );     cout &lt;&lt;  After swapped by using call by reference :\\nreference1 is   &lt;&lt; reference1 &lt;&lt;   and reference2 is   &lt;&lt; reference2 &lt;&lt;  \\n\\n ;     return 0; } // main()  輸出：    參照：  https://dotblogs.com.tw/Ace_Dream/2016/06/01/callbyvalue_callbyaddress_callbyreference  https://hackmd.io/@yunfanlu/r1xryJdSI#Call-by-reference",
        "output": "評論:Excellent summary! 評論:Good."
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明傳值呼叫call by value。  答案: call by value:當副程式呼叫主程式的值後會把原本在記憶體裡面的值複製之後，將複製後的值傳到另一個記憶體的位置上，而副程式的值就是使用複製後的記憶體位置，因此那個值如何更改都不會改變主程式原本的值。   call by reference: 當副程式呼叫主程式的值後會直接取主程式的值的記憶體位置，因此之後的變動都是在同一個記憶體做運算，所以回到主程式後得到的值是會隨著運算變動。",
        "output": "評論:👍 評論:Good👍 評論:👏 評論:讚喔  解說很詳細 評論:不錯"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 寫出C++程式碼說明傳值呼叫call by value。  答案: call by value引用變數數值而call by reference引用變數本身，當含有call by value參數的函數被呼叫時， 該變數數值會被複製，函數只能改動複製後的值。而call by reference則不複製，與主程式變數使用相同的記憶體位置。  call by value 因為要複製參數的值，在呼叫上會花較多時間，影響效能，但可保護主程式的值不被任意更改。  call by reference -&gt; 與call by value 相比較不影響效能，但有時並不希望主程式的值被更動。  # include &lt;iostream&gt; using namespace std;  void RefAndVal( int &amp; ref, int val ) {     ref = ref * 2;     val = val * 2; } // ByReference  int main() {     int ref = 5 , val = 5;     cout &lt;&lt;  Before :   &lt;&lt; ref &lt;&lt; endl;     cout &lt;&lt;  After call by reference :   &lt;&lt; ref &lt;&lt; endl;     cout &lt;&lt;  After call by value :   &lt;&lt; val &lt;&lt; endl;      return 0; } // main",
        "output": "評論:Good! 評論:👍 評論:good! 評論:👍 評論:goodddddd"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 將此後序式postfix轉中序式infix，並詳述步驟。a b + c * d e + f * + w z + *  答案: 我的作法是先把這個以後序表示法表示的式子以二元樹的方式儲存(這個二元樹經Postorder traversal後會得到原本後續後序表示法的式子) 因為在中序表示法中，乘法及除法的運算優先順序高於加法及減法，也就是說中序表示法需考慮運算元的優先順序。 所以當運算優先順序較高的節點，其左節點或右節點的運算優先順序低於此節點， 表示在中序表示法中，需將左節點或右節點表示成中序表示法後，在其左右兩邊加上括號，才能讓左節點或右節點能夠先被計算。  過程:    以 a b + c * d e + f * + w z + * 建出來的二元樹長的像是這樣，其中黑底字表示的是此端點轉成中序表示式的結果。    以C++實作大概是",
        "output": "評論:1.  先把這個以後序表示法表示的式子以二元樹的方式儲存  未解說第一步如何建樹？  2. 完全沒有註解的程式碼？  3."
    }
]