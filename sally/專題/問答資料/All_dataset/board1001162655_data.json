[
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 舉例解說希爾排序shell sort是否穩定stable。  答案: 假設 現在有一組數字為{4,3,3,8,7}，將gap=2,就會是由[4,3,7]以及[3,8]這兩組內比較，比較完後為{3,3,4,8,7}，之後再以gap=1下去比較，產生出排序為{3,3,4,7,8}由這裡可以看出若是有相同數字在數列中，可能會導致原先在前的會排到原先在後的後面，這也就是shell sort不穩定的原因。",
        "output": "評論:Nice example &amp; explanation."
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 舉例解說快速排序quick sort是否穩定stable。  答案: 若待排序數組: int a[] ={1, 2, 2, 3, 4, 5, 6};  在快速排序的隨機選擇比較子(即pivot)階段：  若選擇a[2]（即數組中的第二個2）為比較子，，而把大於等於比較子的數均放置在大數數組中，則a[1]（即數組中的第一個2）會到pivot的右邊， 那麼數組中的兩個2非原序（這就是「不穩定」）。  若選擇a[1]為比較子，而把 小於等於比較子的數均放置在小數數組中，則數組中的兩個2順序也非原序    這就說明，quick sort是不穩定的。",
        "output": "評論:把大於等於比較子的數均放置在大數數組中  和  把 小於等於比較子的數均放置在小數數組中   應該不會同時成立， 等於 的數要放在哪一組？演算法設計只會擇一。  明確指出演算法步驟(不能模擬兩可)，再舉例說明。"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 舉例區別前序preorder、中序inorder及後序postorder二元樹走訪的差異。  答案: 前序：順序是根節點、左子節點、右子節點，根排在前面。 \t[1, 2, 4, 7, 8, 5, 3, 6, 9, 10] \t中序：順序是左子節點、根節點、右子節點，根排在中間。 \t[7, 4, 8, 2, 5, 1, 3, 9, 6, 10] \t後序：順序是左子節點、右子節點、根節點，根排在後面。 \t[7, 8, 4, 5, 2, 9, 10, 6, 3, 1]",
        "output": "評論:Good!"
    },
    {
        "instruction": "請根據以下問題的回答作出評論，並判斷回答是否正確",
        "input": "題目: 舉例解說快速排序quick sort是否穩定stable。  答案: 修改：  對一數列(4,5,6,5,3,5)排序，為方便辨別5的原本位置將數列標為(4,5A,6,5B,3,5C)，過程如下：  (4,5A,6,5B,3,5C)，pivot和lastS1為4位置 5A,6,5B都&gt;pivot，數列和lastS1不變 3&lt;pivot，與5A交換(lastS1+1位置)，數列變成(4,3,6,5B,5A,5C)，lastS1為3的位置 5C&gt;pivot，數列和lastS1不變 將pivot與lastS1交換，數列變成(3,4,6,5B,5A,5C)，4位置不再變動，數列(3)(4)(6,5B,5A,5C)，S1不需再排，S2繼續排序  (6,5B,5A,5C)，pivot和lastS1為6位置 對數列進行同第一輪的排序步驟後，會得到數列(6,5B,5A,5C)，且lastS1=5C位置 將pivot與lastS1交換，得到數列(5C,5B,5A,6)  最終數列由(4,5A,6,5B,3,5C)經排序變為(3,4,5C,5B,5A,6)，三個5的順序和原本不同。在排序進行交換的時候可能會把元素的穩定性打亂，所以快速排序是一個不穩定的排序。  --------------------------------------------------------------------------------------------------------  對一數列(5,3,6,4,3)排序，為方便辨別3的原本位置將數列標為(5,3A,6,4,3B)  定義三個量i, j , pivot。i是數組第一個值的位置即i=0， j是數組最後一個值的位置即j=4，pivot取數列第一個值=5，過程如下：  從j(=4)開始向前找到第一個比pivot小的數為位置4的3B,與pivot交換得到新數列(3B,3A,6,4,5), j=4　  從i(=0)開始向後找到第一個比pivot大的數為位置2的6,與pivot交換得到新數列(3B,3A,5,4,6), i=2　  從j(=4)開始向前找到第一個比pivot小的數為位置3的4,與pivot交換得到新數列(3B,3A,4,5,6), j=3　  從i(=2)開始向後找到比pivot大的數，發現在j之前已經找不到比5更大的數，此時該輪排序結束。再將5前後的數重新定義成新的數列(3B,3A,4)(5)(6)，分別對它們重複剛才的過程，直到每個重新劃分的區域內只有一個值，排序完成。最終的排序結果為(3B)(3A)(4)(5)(6)。  上述的舉例中，數列由(5,3A,6,4,3B)經過排序後變為(3B,3A,4,5,6)，原本3A在3B之前，排序後變成3B在3A之前，在pivot和數列元素進行交換的時候，就可能把前面的元素的穩定性打亂，所以快速排序是一個不穩定的排序。",
        "output": "評論:演算法並非教材的原始版本。  原始版本中pivot位置是固定的，另外有一個邊界位置朝一個方向移動，數值只和移動邊界的位置交換。  假設從小到大是往右的方向，只有比pivot小的數值才需要和邊界位置交換，比較大的數值都留在原處。  考試別答錯了..."
    }
]