[
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 算式 : 2 4 6 * + 7 5 - *\n先將 2 4 6 放入 Stack\n讀到 * ，將 4 跟 6 從 Stack 中拔掉，計算出 4 * 6 = 24 後 將 24 丟回去 Stack\n再讀 + ， 將2跟24從Stack中拔掉，計算出 2 + 24 = 26 後 將 26 丟回去 Stack\n然後再將 7 跟 5 丟入 Stack ( Stack 裡面有 26 7 5 )\n讀到 - ，將 7 跟 5 取出，計算出 7 - 5 = 2 後 丟回去 Stack\n讀到 *， 將 26 跟 2 取出 計算出 26 * 2 = 52後 丟回去 Stack\n讀完了，將Stack最上層的元素，也就是答案，送出去\nAns. = 52\n\n\n\n參考資源 : 老師的影片\n想測試自己寫的程式碼 : https://leetcode.com/problems/evaluate-reverse-polish-notation/",
        "output": "題目只是問求解過程，和作業相關時，請勿列出詳細的程式碼。"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 不是，因爲做到中間時，前面已經形成一個前序，而後面接上了一個非空字串",
        "output": "OK."
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 若想產生3個數字不同且加總等於M的所有3位數，且百位數必須非0，則這三個數字必皆為個位數。\n\n=&gt; 必須注意最大的M是24 = 9 + 8 + 7，而最小的M是3 = 2 + 1 + 0。\n\n總共填3次，第一次填1~limit，第二次填0~limit(若第一次填的數字在內，需跳過其)，第三次只填一個(M減掉前兩次填的數字)。\n\nlimit是填入後不會使後面的數字填不了的最大數字，如M = 9時，limit = 8，因為8後面尚可填1&amp;0；或是如M = 9且第一個數是7時，limit = 2，因為7、2後面尚可填0。\n\n以下是程式碼：\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std ;\n\nint permuCount = 0 ;      // to record the total amounts of permutation in a case.\nvector&lt;int&gt; empty ;       // an empty array.\n\nbool isRecur = false ;     // indicates if the recurive function is on its first time or recursing.\nvoid permuPrinter( vector&lt;int&gt; arr ) ;\nvoid allThreeNumSumUpAsM( vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; recur, int target, int currentItem ) ;\n\nint main() {\n    int m = 0 ;\n     vector&lt;int&gt; arr ;    \n    \n    cout &lt;&lt;  \\nPlease insert a positive number M:   ;\n    for( ; m &lt; 1 ; ) {\n          cin &gt;&gt; m  ;\n        if( m &lt; 1 || cin.fail() ) {\n              cout &lt;&lt;  Invalid input, please try again.\\n  ;\n              cin.clear() ;        // if cin failed, reset its flag ( fail: invalid type.  e.g. cin &#39;a&#39; to an int variable).\n              cin.sync() ;         // and clear its temp.           ( without this, next cin will change its flag to fail and stop cin immediately.)\n        } // end of if\n                    \n    } // end of for\n                \n    cout &lt;&lt;  \\n\\nResult: \\n  ;\n                \n    // make arr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n    arr.clear() ;\n    for( int first = 0 ; first &lt;= 9 ; first++ ) {\n        arr.push_back(first) ;\n    } // end of for\n                \n    empty.resize(3) ;            // Rest empty to a n items array full of 0.\n    permuCount = 0 ;\n    allThreeNumSumUpAsM( arr, empty, m, 0 ) ;\n} // main()\n\n\nvoid allThreeNumSumUpAsM( vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; recur, int target, int currentItem ) {\n    vector&lt; vector&lt;int&gt; &gt; result( 9, vector&lt;int&gt;(3) ) ;\n    int idxArr = 0 ;\n    int idx1 = 0 ;\n    int idx2 = 0 ;\n    int limit = 9 ;\n    int addTimes = 9 ;\n    \n    // if target is less than 3 or larger than 24, for example = 2, then we wouldn&#39;t be able to find the 3 numbers. \n    if( target &gt;= 3 &amp;&amp; target &lt;= 24 ) {\n        if( currentItem == 0 ) {\n            idxArr = 1 ; // result can&#39;t be something like  031  or  049 , so possible number for first are 1~9.\n            while( target - limit &lt;= 0 ) { // e.g. if m = 9, then first number&#39;s max is 8 for  810  and  801 .\n                limit = limit - 1 ;\n               } // end of while\n           \n            addTimes = limit - idxArr + 1 ; // first time, possible numbers are from 1 to limit.\n        } // end of if\n    \n        else if( currentItem == 1 ) { // e.g. if m = 9 and first number = 8, then second number&#39;s max is 1 for  810  and  801 .\n            while( target - recur[0] - limit &lt; 0 ) {\n                limit = limit - 1 ; \n               } // end of while\n               \n            addTimes = limit - idxArr + 1 ; // second time, possible numbers are from 0 to limit, except the first number.\n            if( recur[0] &lt;= limit &amp;&amp; recur[0] &gt;= idxArr ) {\n                addTimes = addTimes - 1 ;\n            } // end of if\n            \n        } // end of else if\n        \n        else if( currentItem == 2 ) { // third or the last number will be target - recur[0] - recur[1].\n            idxArr = target - recur[0] - recur[1] ;\n            limit = target - recur[0] - recur[1] ;\n            if( limit &gt; 9 ) {\n                currentItem = 100 ; // if limit is bigger than 9, then this combination is impossible.\n            } // end of if\n            \n            addTimes = 1 ; // only 1 possible number for third time.\n        } // end of else if\n        \n            \n        for( idx1 = 0 ; idx1 &lt; addTimes &amp;&amp; currentItem &lt; 3 ; idx1++ ) {\n            for( idx2 = 0 ; idx2 &lt; 3 &amp;&amp; isRecur ; idx2++ ) {\n                result[idx1].at(idx2) = recur[idx2] ;\n            } // end of for\n            \n            for( bool isAdded = false ; idxArr &lt;= limit &amp;&amp; !isAdded ; idxArr++ ) {\n                if( find( result[idx1].begin(), result[idx1].end(), arr[idxArr] ) == result[idx1].end() ) {\n                    result[idx1].at(currentItem) = arr[idxArr] ;\n                    isAdded = true ;\n                } // end of if\n                \n            } // end of for\n            \n        } // end of for\n        \n        if( currentItem == 3 ) {\n            for( idx2 = 0 ; idx2 &lt; 3 &amp;&amp; isRecur ; idx2++ ) {\n                result[0].at(idx2) = recur[idx2] ;\n            } // end of for\n            \n            if( result[0][0] + result[0][1] + result[0][2] == target ) {\n                permuPrinter( result[0] ) ;\n            } // end of if\n            \n        } // end of if\n    \n        else if( currentItem &lt; 3 ) {\n                isRecur = true ;\n                for( idx1 = 0 ; idx1 &lt; addTimes ; idx1++ ) {\n                allThreeNumSumUpAsM( arr, result[idx1], target, currentItem + 1 ) ;\n            } // end of for\n            \n        } // end of else if\n    \n    } // end of if\n    \n    else {\n        cout &lt;&lt;  Unable to find 3 number which sum up as   &lt;&lt; target &lt;&lt;  \\n  ;\n    } // end of else\n        \n} // allThreeNumSumUpAsM()\n\nvoid permuPrinter( vector&lt;int&gt; arr ) {\n    permuCount = permuCount + 1 ;\n    cout &lt;&lt;  【  &lt;&lt; permuCount &lt;&lt;  】   ;\n    for( int idx = 0 ; idx &lt; 3 ; idx++ ) {\n            cout &lt;&lt; arr[idx] &lt;&lt;     ;\n    } // end of for\n       cout &lt;&lt;  \\n  ;\n} // permuPriter()",
        "output": "程式碼可以正常執行，敘述邏輯的表達清楚。\n\n內部有二個while迴圈可否簡化成if敘述直接計算？\n\n例如這個：\n\nwhile( target - recur[0] - limit &lt; 0 ) {\n                limit = limit - 1 ; \n               } // end of while 延伸閱讀：\n\n維基百科: https://en.wikipedia.org/wiki/Subset_sum_problem\n\n學術論文：https://ieeexplore.ieee.org/document/9504889"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 1. 將2,4,6依序放入stack\n\n2. 讀進*，從stack中取出6和4，做運算4*6=24，將24放入stack\n\n3. 讀進+，從stack中取出24和2，做運算2+24=26，將26放入stack\n\n4. 將7,5依序放入stack\n\n5. 讀進-，從stack中取出5和7，做運算7-5=2，將2放入stack\n\n6. 讀進*，從stack中取出26和2，做運算2*26=52，將52放入stack\n\n7. 沒有東西讀進來，stack中的52即為最終答案",
        "output": "OK"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 後序式2 4 6 * + 7 5 - *如何透過堆疊求解?\n\n1.2, 4, 6直接放入數字堆疊\n\n2.4, 6經過*計算得到24放回堆疊(目前的數字堆疊為2, 24)\n\n3.2,24經過+計算得到26放回堆疊(目前的數字堆疊為26)\n\n4.7, 5放入數字堆疊(目前的數字堆疊為26, 7, 5)\n\n5.7,5經過-計算得到2放回堆疊(目前的數字堆疊為26, 2)\n\n6.26, 2經過*計算得到52放回堆疊(目前的數字堆疊為52)\n\n7.運算式結束，數字堆疊剩下一個元素，也沒有多餘的運算子，為合法的後序式，結束計算，答案52。",
        "output": "可，比前一篇貼文多了堆疊內容。"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 堆疊放運算元當讀到運算子時pop兩個運算元與運算子做計算然後算出來的result push回去堆疊，最終的result即為答案。",
        "output": "OK"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: /*\n\n類別圖：\n\n\n\n在C++中，是透過stream的子類fstream(file stream)對檔案操作，所以要加入標頭檔&lt;fstream.h&gt;。\n\nstream類別中有兩個重要的運算子：\n\n1. 插入器&lt;&lt;：向流輸出資料。例如標準輸出流cout：cout &lt;&lt;  COUT ;就表示把字串 COUT 輸出到cout。\n2. 析取器&gt;&gt;：從流中輸入資料。例如標準輸入流cin：cin &gt;&gt; x;就表示從cin中讀取一個指定型別的資料輸入到x。\n\n因此，寫檔時，可用插入器將資料輸入到檔案。\n\nfstream有兩個子類：ifstream(input file stream)和ofstream(outpu file stream)。\n\nifstream預設以輸入模式開啟檔案（從硬碟到記憶體），ofstream預設以輸出模式開啟檔案（從記憶體到硬碟）。\n\n如果想以輸入模式開啟就用ifstream，想以輸出方式開啟就用ofstream，想以輸入/輸出方式來開啟fstream（個人偏好ifstream和ofstream，較易區分）。\n\nifstream和ofstream中，開啟檔案為open()，關閉檔案為close()。\n\n1. open()：\n\n原型：\n\nvoid open (const char* filename, ios_base::openmode mode = ios_base::in); // ifstream\n\nvoid open (const char* filename, ios_base::openmode mode = ios_base::out); // ofstream\n\nfilename為檔名，mode為開啟方式。\n\n流的文件關聯由其內部流緩衝區保存：\n在內部，函數調用rdbuf()-&gt;open(filename,mode)\n\n（內部流緩衝區請參照標準函式庫：https://cplusplus.com/reference/fstream/filebuf/open/）\n\n2. close()：\n\n原型：void close();\n\n關閉當前與對象關聯的文件，將其與流解除關聯。\n\n流的文件關聯由其內部流緩衝區保存：\n在內部，函數調用和設置rdbuf-&gt;close()，並設置failbit預防失敗。\n\n（內部流緩衝區請參照標準函式庫：https://cplusplus.com/reference/fstream/filebuf/close/）\n\n3. 有另一種方式在建構時就可開啟檔案（程式碼使用此種方式）：\n\n建構ifstream時開啟：https://cplusplus.com/reference/fstream/ifstream/ifstream/\n\n\n\t\n\t\t\n\t\t\tdefault (1)\n\t\t\t\n\t\t\tifstream();\n\t\t\t\n\t\t\n\t\t\n\t\t\tinitialization (2)\n\t\t\t\n\t\t\texplicit ifstream (const char* filename, ios_base::openmode mode = ios_base::in);explicit ifstream (const string&amp; filename, ios_base::openmode mode = ios_base::in);\n\t\t\t\n\t\t\n\t\t\n\t\t\tcopy (3)\n\t\t\t\n\t\t\tifstream (const ifstream&amp;) = delete;\n\t\t\t\n\t\t\n\t\t\n\t\t\tmove (4)\n\t\t\t\n\t\t\tifstream (ifstream&amp;&amp; x);\n\t\t\t\n\t\t\n\t\n\n\n建構ofstream時開啟：https://cplusplus.com/reference/fstream/ofstream/ofstream/\n\n\n\t\n\t\t\n\t\t\tdefault (1)\n\t\t\t\n\t\t\tofstream();\n\t\t\t\n\t\t\n\t\t\n\t\t\tinitialization (2)\n\t\t\t\n\t\t\texplicit ofstream (const char* filename, ios_base::openmode mode = ios_base::out);explicit ofstream (const string&amp; filename, ios_base::openmode mode = ios_base::out);\n\t\t\t\n\t\t\n\t\t\n\t\t\tcopy (3)\n\t\t\t\n\t\t\tofstream (const ofstream&amp;) = delete;\n\t\t\t\n\t\t\n\t\t\n\t\t\tmove (4)\n\t\t\t\n\t\t\tofstream (ofstream&amp;&amp; x);\n\t\t\t\n\t\t\n\t\n\n\n補充個在stackoverflow看到的，別人的問題：https://stackoverflow.com/questions/3847611/c-stdifstream-in-constructor-problem\n\n4. 由於open內使用字串常數，因此我使用c_str()將string轉換成AnsiString。\n\n原型：const char* c_str() const;\nc_str() 會把字串物件轉換成字串常數，由於轉換後變成常數，因此不能任意更改。若必須更改字串常數，應先將其儲存到buffer再更改。\n\n*/\n\n#include &lt;iostream&gt;\n\n#include &lt;fstream&gt;\n\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n\n    /*\n\n    原本有個叫ABC.txt的檔案有三行內容\n\n    我先讀進來存到vector\n\n    再新建一個複製檔，寫入舊資料，並新增三行內容\n\n    註：此程式碼檔案必須與ABC.txt放在同一資料夾\n\n    產生的複製檔也會在此資料夾內\n\n    */\n\n    // 變數宣告\n\n    vector&lt;string&gt; vec ; // 存檔案的每一行\n\n    string nameStr =  ABC.txt ; // 檔案名稱，見附件\n\n    string toStoreStr =   ; // 暫存檔案的每一行\n\n    // ifstream：讀檔\n\n    ifstream toOpen(nameStr.c_str()); // 以讀取模式開啟檔案 // 【讀檔】\n\n    while (getline(toOpen, toStoreStr)) vec.push_back(toStoreStr); // 逐行寫入vector\n\n    toOpen.close(); // 以讀取模式關閉檔案\n\n    cout &lt;&lt;  Original file&#39;s data :  &lt;&lt; endl;\n\n    for (int i = 0; i &lt; vec.size(); i++) cout &lt;&lt; vec[i] &lt;&lt; endl; // 印出檔案的每一行\n\n    // ofstream：寫檔\n\n    nameStr =  copy  + nameStr;\n\n    ofstream copyFile(nameStr.c_str()); // 建立一個新的複製檔並以寫入模式開啟複製檔\n\n    for (int i = 0; i &lt; vec.size(); i++) copyFile &lt;&lt; vec[i] &lt;&lt; endl; // 複製舊檔資料到複製檔\n\n    vec.erase(vec.begin(), vec.end()); // 清空重置vector\n\n    for (int i = 0; i &lt; 3; i++) vec.push_back( write : line   + to_string(i+4)); // 存在vector內的新資料\n\n    for (int i = 0; i &lt; vec.size(); i++) copyFile &lt;&lt; vec[i] &lt;&lt; endl; // 使用插入器寫入新資料 // 【寫檔】\n\n    copyFile.close(); // 以寫入模式關閉複製檔\n\n    // 印出修改後的內容\n\n    vec.erase(vec.begin(), vec.end()); // 清空重置vector\n\n    toStoreStr =   ; // 清空重置暫存字串\n\n    ifstream openCopyFile(nameStr.c_str()); // 以讀取模式開啟複製檔\n\n    while (getline(openCopyFile, toStoreStr)) vec.push_back(toStoreStr); // 逐行寫入vector\n\n    cout &lt;&lt;  Copyed and altered file&#39;s data :  &lt;&lt; endl;\n\n    for (int i = 0; i &lt; vec.size(); i++) cout &lt;&lt; vec[i] &lt;&lt; endl; // 印出檔案的每一行\n\n    openCopyFile.close(); // 以讀取模式關閉複製檔\n\n    /*\n\n    執行結果：\n\n    (1)印出以下內容\n\n    Original file&#39;s data :\n\n    read : line 1\n\n    read : line 2\n\n    read : line 3\n\n    Copyed and altered file&#39;s data :\n\n    read : line 1\n\n    read : line 2\n\n    read : line 3\n\n    write : line 4\n\n    write : line 5\n\n    write : line 6\n\n    (2)產生總計六行資料的複製檔copyABC.txt\n\n    */\n\n} // main()",
        "output": "問題的重點是 介紹一組讀檔和寫檔的指令 \n\n請明確指出哪幾個是讀檔和寫檔的指令，並介紹指令的用法或原理。"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: ",
        "output": "OK"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 後序式求值：\n\n\n\t遇到數字push進堆疊，遇到運算符號就pop出堆疊最上層兩個數字進行運算再將答案push進堆疊\n\t \n\n\n\n\t將 2、4、6 三個數字依序push進stack中\n\t讀到 * 取出stack最上層兩數 4 6 進行運算得到答案為 4*6 = 24 並將 4 6 從stack中移除，再將 24 push回stack\n\t讀到 + 取出取出stack最上層兩數 24 2 進行運算得到 24 + 2 = 26 並將 24 2 從stack中移除，再將 26 push回stack\n\t將 7、5 兩個數字依序push進stack中\n\t讀到 - 取出取出stack最上層兩數 5 7 進行運算得到 7 - 5 = 2 並將 7 5 從stack中移除，再將 2 push回stack\n\t讀到 * 取出取出stack最上層兩數 2 26 進行運算得到 2 * 26 = 52 並將 2 26 從stack中移除，再將52push回stack\n\t字串全部讀完，stack中剩下一數 52 即為最後的答案",
        "output": "good 讚喔 good"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 9：ios::out是指將檔案以寫入模式開啟\n\n\n\n20：ios::in是指將檔案以讀取模式開啟",
        "output": "讚 good!"
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 後序式2 4 6 * + 7 5 - *\n\n1.遇到數字把數字丟進stack裡面，此時的stack為[2, 4, 6] (下-&gt;上)\n\n2.遇到運算子把堆疊最上面兩個數字做運算，並將運算結果丟回stack裡面，4*6=24，此時的stack為[2, 24]\n\n3.遇到運算子把堆疊最上面兩個數字做運算，2+24=26，此時的stack為[26]\n\n4.把數字丟進stack裡面，此時的stack為[26, 7, 5]\n\n5.遇到運算子把堆疊最上面兩個數字做運算，7-5=2，此時的stack為[26,2]\n\n6.遇到運算子把堆疊最上面兩個數字做運算，26*2=52，此時的stack為[52]\n\n7.運算結束，結果為stack剩下的數字：52",
        "output": ""
    },
    {
        "instruction": "請根據以下答案做出評論",
        "input": "題目: \n答案: 如題。\n到目前為止，共計53位同學問答已得分。",
        "output": ""
    }
]