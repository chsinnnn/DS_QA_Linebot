{
    "data": {
        "@version": "3.0",
        "@time": "2024-07-19 08:59:51",
        "@type": "post",
        "@filename": "b000000007.xml",
        "open_time": "0000-00-00",
        "close_time": "0000-00-00",
        "lang_name": "Big5",
        "board_id": "1001174276",
        "node": "000000007",
        "site": "1000110001",
        "pt": "2022-10-26 16:16:00",
        "poster": "11020107",
        "realname": "蘇伯勳",
        "email": "pohsun.su@gmail.com",
        "homepage": null,
        "subject": "127. 寫C++程式碼介紹一組讀檔和寫檔的指令，須能成功編譯執行。",
        "content": "<p>/*</p>\r\n\r\n<p>類別圖：</p>\r\n\r\n<p><a href=\"https://cplusplus.com/img/iostream.gif\"><img alt=\"\" src=\"https://cplusplus.com/img/iostream.gif\" style=\"height:273px; width:705px\" /></a></p>\r\n\r\n<p>在C++中，是透過stream的子類fstream(file stream)對檔案操作，所以要加入標頭檔&lt;fstream.h&gt;。</p>\r\n\r\n<p>stream類別中有兩個重要的運算子：</p>\r\n\r\n<p>1. 插入器&lt;&lt;：向流輸出資料。例如標準輸出流cout：cout &lt;&lt; &quot;COUT&quot;;就表示把字串&quot;COUT&quot;輸出到cout。<br />\r\n2. 析取器&gt;&gt;：從流中輸入資料。例如標準輸入流cin：cin &gt;&gt; x;就表示從cin中讀取一個指定型別的資料輸入到x。</p>\r\n\r\n<p>因此，寫檔時，可用插入器將資料輸入到檔案。</p>\r\n\r\n<p>fstream有兩個子類：ifstream(input file stream)和ofstream(outpu file stream)。</p>\r\n\r\n<p>ifstream預設以輸入模式開啟檔案（從硬碟到記憶體），ofstream預設以輸出模式開啟檔案（從記憶體到硬碟）。</p>\r\n\r\n<p>如果想以輸入模式開啟就用ifstream，想以輸出方式開啟就用ofstream，想以輸入/輸出方式來開啟fstream（個人偏好ifstream和ofstream，較易區分）。</p>\r\n\r\n<p>ifstream和ofstream中，開啟檔案為open()，關閉檔案為close()。</p>\r\n\r\n<p>1. open()：</p>\r\n\r\n<p>原型：</p>\r\n\r\n<p>void open (const char* filename, ios_base::openmode mode = ios_base::in); // ifstream</p>\r\n\r\n<p>void open (const char* filename, ios_base::openmode mode = ios_base::out); // ofstream</p>\r\n\r\n<p>filename為檔名，mode為開啟方式。</p>\r\n\r\n<p>流的文件關聯由其內部流緩衝區保存：<br />\r\n在內部，函數調用rdbuf()-&gt;open(filename,mode)</p>\r\n\r\n<p>（內部流緩衝區請參照標準函式庫：<a href=\"https://cplusplus.com/reference/fstream/filebuf/open/\">https://cplusplus.com/reference/fstream/filebuf/open/</a>）</p>\r\n\r\n<p>2. close()：</p>\r\n\r\n<p>原型：void close();</p>\r\n\r\n<p>關閉當前與對象關聯的文件，將其與流解除關聯。</p>\r\n\r\n<p>流的文件關聯由其內部流緩衝區保存：<br />\r\n在內部，函數調用和設置rdbuf-&gt;close()，並設置failbit預防失敗。</p>\r\n\r\n<p>（內部流緩衝區請參照標準函式庫：<a href=\"https://cplusplus.com/reference/fstream/filebuf/close/\">https://cplusplus.com/reference/fstream/filebuf/close/</a>）</p>\r\n\r\n<p>3. 有另一種方式在建構時就可開啟檔案（程式碼使用此種方式）：</p>\r\n\r\n<p>建構ifstream時開啟：<a href=\"https://cplusplus.com/reference/fstream/ifstream/ifstream/\">https://cplusplus.com/reference/fstream/ifstream/ifstream/</a></p>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<th>default (1)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>ifstream();</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<th>initialization (2)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>explicit ifstream (const char* filename, ios_base::openmode mode = ios_base::in);explicit ifstream (const string&amp; filename, ios_base::openmode mode = ios_base::in);</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<th>copy (3)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>ifstream (const ifstream&amp;) = delete;</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<th>move (4)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>ifstream (ifstream&amp;&amp; x);</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<p>建構ofstream時開啟：<a href=\"https://cplusplus.com/reference/fstream/ofstream/ofstream/\">https://cplusplus.com/reference/fstream/ofstream/ofstream/</a></p>\r\n\r\n<table>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<th>default (1)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>ofstream();</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<th>initialization (2)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>explicit ofstream (const char* filename, ios_base::openmode mode = ios_base::out);explicit ofstream (const string&amp; filename, ios_base::openmode mode = ios_base::out);</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<th>copy (3)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>ofstream (const ofstream&amp;) = delete;</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<th>move (4)</th>\r\n\t\t\t<td>\r\n\t\t\t<p>ofstream (ofstream&amp;&amp; x);</p>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n<p>補充個在stackoverflow看到的，別人的問題：<a href=\"https://stackoverflow.com/questions/3847611/c-stdifstream-in-constructor-problem\">https://stackoverflow.com/questions/3847611/c-stdifstream-in-constructor-problem</a></p>\r\n\r\n<p>4. 由於open內使用字串常數，因此我使用c_str()將string轉換成AnsiString。</p>\r\n\r\n<p>原型：const char* c_str() const;<br />\r\nc_str() 會把字串物件轉換成字串常數，由於轉換後變成常數，因此不能任意更改。若必須更改字串常數，應先將其儲存到buffer再更改。</p>\r\n\r\n<p>*/</p>\r\n\r\n<p>#include &lt;iostream&gt;</p>\r\n\r\n<p>#include &lt;fstream&gt;</p>\r\n\r\n<p>#include &lt;vector&gt;</p>\r\n\r\n<p>using namespace std;</p>\r\n\r\n<p>int main() {</p>\r\n\r\n<p>&nbsp; &nbsp; /*</p>\r\n\r\n<p>&nbsp; &nbsp; 原本有個叫ABC.txt的檔案有三行內容</p>\r\n\r\n<p>&nbsp; &nbsp; 我先讀進來存到vector</p>\r\n\r\n<p>&nbsp; &nbsp; 再新建一個複製檔，寫入舊資料，並新增三行內容</p>\r\n\r\n<p>&nbsp; &nbsp; 註：此程式碼檔案必須與ABC.txt放在同一資料夾</p>\r\n\r\n<p>&nbsp; &nbsp; 產生的複製檔也會在此資料夾內</p>\r\n\r\n<p>&nbsp; &nbsp; */</p>\r\n\r\n<p>&nbsp; &nbsp; // 變數宣告</p>\r\n\r\n<p>&nbsp; &nbsp; vector&lt;string&gt; vec ; // 存檔案的每一行</p>\r\n\r\n<p>&nbsp; &nbsp; string nameStr = &quot;ABC.txt&quot;; // 檔案名稱，見附件</p>\r\n\r\n<p>&nbsp; &nbsp; string toStoreStr = &quot;&quot;; // 暫存檔案的每一行</p>\r\n\r\n<p>&nbsp; &nbsp; // ifstream：讀檔</p>\r\n\r\n<p>&nbsp; &nbsp; ifstream toOpen(nameStr.c_str()); // 以讀取模式開啟檔案 // 【讀檔】</p>\r\n\r\n<p>&nbsp; &nbsp; while (getline(toOpen, toStoreStr)) vec.push_back(toStoreStr); // 逐行寫入vector</p>\r\n\r\n<p>&nbsp; &nbsp; toOpen.close(); // 以讀取模式關閉檔案</p>\r\n\r\n<p>&nbsp; &nbsp; cout &lt;&lt; &quot;Original file&#39;s data :&quot; &lt;&lt; endl;</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; vec.size(); i++) cout &lt;&lt; vec[i] &lt;&lt; endl; // 印出檔案的每一行</p>\r\n\r\n<p>&nbsp; &nbsp; // ofstream：寫檔</p>\r\n\r\n<p>&nbsp; &nbsp; nameStr = &quot;copy&quot; + nameStr;</p>\r\n\r\n<p>&nbsp; &nbsp; ofstream copyFile(nameStr.c_str()); // 建立一個新的複製檔並以寫入模式開啟複製檔</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; vec.size(); i++) copyFile &lt;&lt; vec[i] &lt;&lt; endl; // 複製舊檔資料到複製檔</p>\r\n\r\n<p>&nbsp; &nbsp; vec.erase(vec.begin(), vec.end()); // 清空重置vector</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; 3; i++) vec.push_back(&quot;write : line &quot; + to_string(i+4)); // 存在vector內的新資料</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; vec.size(); i++) copyFile &lt;&lt; vec[i] &lt;&lt; endl; // 使用插入器寫入新資料 // 【寫檔】</p>\r\n\r\n<p>&nbsp; &nbsp; copyFile.close(); // 以寫入模式關閉複製檔</p>\r\n\r\n<p>&nbsp; &nbsp; // 印出修改後的內容</p>\r\n\r\n<p>&nbsp; &nbsp; vec.erase(vec.begin(), vec.end()); // 清空重置vector</p>\r\n\r\n<p>&nbsp; &nbsp; toStoreStr = &quot;&quot;; // 清空重置暫存字串</p>\r\n\r\n<p>&nbsp; &nbsp; ifstream openCopyFile(nameStr.c_str()); // 以讀取模式開啟複製檔</p>\r\n\r\n<p>&nbsp; &nbsp; while (getline(openCopyFile, toStoreStr)) vec.push_back(toStoreStr); // 逐行寫入vector</p>\r\n\r\n<p>&nbsp; &nbsp; cout &lt;&lt; &quot;Copyed and altered file&#39;s data :&quot; &lt;&lt; endl;</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; vec.size(); i++) cout &lt;&lt; vec[i] &lt;&lt; endl; // 印出檔案的每一行</p>\r\n\r\n<p>&nbsp; &nbsp; openCopyFile.close(); // 以讀取模式關閉複製檔</p>\r\n\r\n<p>&nbsp; &nbsp; /*</p>\r\n\r\n<p>&nbsp; &nbsp; 執行結果：</p>\r\n\r\n<p>&nbsp; &nbsp; (1)印出以下內容</p>\r\n\r\n<p>&nbsp; &nbsp; Original file&#39;s data :</p>\r\n\r\n<p>&nbsp; &nbsp; read : line 1</p>\r\n\r\n<p>&nbsp; &nbsp; read : line 2</p>\r\n\r\n<p>&nbsp; &nbsp; read : line 3</p>\r\n\r\n<p>&nbsp; &nbsp; Copyed and altered file&#39;s data :</p>\r\n\r\n<p>&nbsp; &nbsp; read : line 1</p>\r\n\r\n<p>&nbsp; &nbsp; read : line 2</p>\r\n\r\n<p>&nbsp; &nbsp; read : line 3</p>\r\n\r\n<p>&nbsp; &nbsp; write : line 4</p>\r\n\r\n<p>&nbsp; &nbsp; write : line 5</p>\r\n\r\n<p>&nbsp; &nbsp; write : line 6</p>\r\n\r\n<p>&nbsp; &nbsp; (2)產生總計六行資料的複製檔copyABC.txt</p>\r\n\r\n<p>&nbsp; &nbsp; */</p>\r\n\r\n<p>} // main()</p>\r\n\r\n<p><img alt=\"\" src=\"/base/10001/course/10131386/board/1001174276/000000007/D.png\" style=\"height:225px; width:301px\" /></p>",
        "attach": "read_and_write_file.cpp\tWM6358ec4645ff5.cpp\tABC.txt\tWM6358ec4d48cf1.txt",
        "rcount": null,
        "rank": null,
        "hit": "30",
        "lang": "1"
    }
}