{
    "data": {
        "@version": "3.0",
        "@time": "2024-07-19 08:59:46",
        "@type": "post",
        "@filename": "b000000001.xml",
        "open_time": "0000-00-00",
        "close_time": "0000-00-00",
        "lang_name": "Big5",
        "board_id": "1001174275",
        "node": "000000001",
        "site": "1000110001",
        "pt": "2022-10-21 17:48:27",
        "poster": "11027229",
        "realname": "卓榮暉",
        "email": "intercoursedr@gmail.com",
        "homepage": null,
        "subject": "123. 寫C++程式碼說明如何複製一整個鏈結串列linked list到另一個變數。",
        "content": "<p>因為 LinkedList本身的資料與指標是環環相扣的，因此無法單純的直接讓新的 Head 指向原本的 Head 的 Next<br />\r\n否則改動新的LinkedList，舊的也會跟著改動。</p>\r\n\r\n<p>那既然要實現複製的話，就只能使用狠暴力的方式 : 那就是將每個節點走訪，並且將內容推向新的 LinkedList。<br />\r\n( 可能有更方便的方式，只是我目前想到的是這個 )</p>\r\n\r\n<p>以下是程式碼的部分</p>\r\n\r\n<p>#include&lt;string.h&gt;<br />\r\n#include&lt;iostream&gt;<br />\r\n#include&lt;stdlib.h&gt;<br />\r\n#include&lt;sstream&gt;</p>\r\n\r\n<p>using namespace std; // 我就懶&nbsp;<br />\r\n// -*- c++ 11 -*-</p>\r\n\r\n<p>// Node<br />\r\n// 利用泛型實作<br />\r\ntemplate &lt;typename T&gt;<br />\r\nstruct Node {<br />\r\n&nbsp;&nbsp; &nbsp;T num; // 資料<br />\r\n&nbsp;&nbsp; &nbsp;Node * next; // 下一個點&nbsp;<br />\r\n};</p>\r\n\r\n<p>// 利用泛型實作LinkedList<br />\r\n// 殘缺的LinkedList, 不過可以應付這題<br />\r\ntemplate &lt;typename T&gt;<br />\r\nclass LinkedList {<br />\r\n&nbsp;&nbsp; &nbsp;public:<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 建構子<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 初始化資料<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;LinkedList() {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;head = NULL; // 頭先設定為NULL&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tail = NULL; // 尾也先設定為NULL&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;size = 0;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 把資料放進去<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void push(T data) {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 如果裡面空空的<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(size==0) {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;head = new Node&lt;T&gt;; // 讓head變成新的Node<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;head -&gt; num = data; // 把資料放進去<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;head -&gt; next = NULL; // 指定head的next是null<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;size++; // 讓size++<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tail = head;// 讓tail變成head<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return; // return 回去 避免進入下一行<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 要是不是空的話<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tail -&gt; next = new Node&lt;T&gt;; // 先讓tail的下一個變成新的Node<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tail = tail -&gt; next; // 把tail 移到下一層<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tail -&gt; num = data;// 把資料放進去<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tail -&gt; next = NULL; // tail的下一個指定為NULL<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;size++;// size增加<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return;// return 回去 可加可不加<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 單純的複製LinkedList<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 這邊是產生一個新的LinkedList 而不是把原本的return回去<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 因為如果是把原本的return回去，會導致資料會被互相引響<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;LinkedList copy() {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;LinkedList toReturn; // 準備回傳回去的資料<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Node&lt;T&gt; * temp = head; // 指標 用來走訪整個LinkedList<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while(temp!=NULL) {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;toReturn.push(temp-&gt;num); // 透過方法一直去push資料<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;temp = temp -&gt; next;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return toReturn; // return</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 透過 index 去取得資料<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;T getDataFromIndex(int k) {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Node&lt;T&gt; * temp = getFromIndex(k);<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return temp -&gt; num;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 透過index 移除資料 並且將資料回傳&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;T removeFromIndex(int k) {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 如果k的大小==0 就代表刪掉頭&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(k==0){<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(head==NULL) return NULL;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;T n = head -&gt; num;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;head = head -&gt; next;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;size--;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return n;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 如果k小於0或者不小於size 就代表越界 因此直接return NULL&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(k&gt;=size || k &lt; 0) return NULL;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 暫時的節點 用來儲存即將被刪除的節點的上一個節點&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Node&lt;T&gt; * temp = getFromIndex(k-1);<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(temp==NULL) return NULL; // 如果取不到 就代表越界 直接 return NULL&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;T n = temp -&gt; next -&gt; num; // N是即將被回傳的值 也就代表被刪除的節點的值&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;temp -&gt; next = temp -&gt; next -&gt; next; // 讓next指向更下一層的節點&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;size--; // size記得要-1&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return n; // return value<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 取得大小&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int getSize() {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return size;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 排序&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; void sortList(){<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head = mergeSort(head);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>\r\n\r\n<p><br />\r\n&nbsp;&nbsp; &nbsp;// 不公開的&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;private:<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Node&lt;T&gt; * head;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Node&lt;T&gt; * tail;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int size;</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 這邊之所以放在private 是為了防止有人透過此方法破壞 LinkedList&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 此方法單純就是將第i個Node回傳&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Node&lt;T&gt; * getFromIndex(int i) {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(i==0) return head;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(i&gt;=size) return NULL;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Node&lt;T&gt; * temp = head;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for(int j = 0 ; j &lt; i ; j++) {<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;temp = temp -&gt; next;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return temp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 將節點排序&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * mergeSort(Node&lt;T&gt; * h){<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 如果 h 的大小只有 1 或者是根本沒東西 直接回傳 h&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(h==NULL||h -&gt; next == NULL) return h;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 找出中心點<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 利用快慢指標&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * slow = h;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * fast = h -&gt; next;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(fast!=NULL&amp;&amp;fast-&gt; next!=NULL){<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fast = fast -&gt; next;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = slow -&gt; next;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * mid = slow -&gt; next;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 找到中心點後 分割開前半部以及後半部&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow -&gt; next = NULL;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 再度分割前半部 並且等待回傳的結果&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * left = mergeSort(h);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 再度分割後半部 並且等待回傳的結果&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * right = mergeSort(mid);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 開頭 Dummy head Node<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * ans = new Node&lt;T&gt;;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 結尾先指向ans&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&lt;T&gt; * last = ans;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 跑回圈 逐漸合併各個節點 並且回傳回去&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(left!=NULL||right!=NULL){<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T n1 = (left != NULL? left -&gt; num : INT_MAX ); // 判斷 left 是不是 NULL 若不是 就指定 n1 為左邊的資料，否則設為 INT_MAX&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T n2 = (right != NULL? right -&gt; num: INT_MAX ); // 判斷 right 是不是 NULL 若不是 就指定 n2 為右邊的資料，否則設為 INT_MAX&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若左邊小於右邊，就讓 last 後面接著左邊&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(n1&lt;n2){<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;last -&gt; next = left;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;left = left -&gt; next;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 否則就做相反的事情&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else{<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;last -&gt; next = right;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;right = right -&gt; next;&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;last = last -&gt; next; // 記得 last 要移動<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 記得不要把dummy head 回傳，而是將dummy head的下一個 ( 也就是真正的頭 ) 回傳&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ans -&gt; next;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;</p>\r\n\r\n<p>};</p>\r\n\r\n<p>int main(){<br />\r\n&nbsp;&nbsp; &nbsp;LinkedList&lt;int&gt; k; // 新增一個 LinkedList&lt;int&gt; k&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;for(int i = 100 ; i &gt;= 0 ; i--){<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;k.push(i); // 將 100 到 0 推進去 k 裡面&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;LinkedList&lt;int&gt; t = k.copy(); // 套copy這個function去複製整個LinkedList<br />\r\n&nbsp;&nbsp; &nbsp;t.sortList(); // 排序 為了證明這兩個LinkedList是不一樣的&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;// 印出k裡面的內容<br />\r\n&nbsp;&nbsp; &nbsp;// 印出資料 100 到 0&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;for(int i = 0 ; i &lt; k.getSize() ; i++){<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf(&quot;%d\\n&quot;,k.getDataFromIndex(i));<br />\r\n&nbsp;&nbsp; &nbsp;}<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;printf(&quot;==================\\n&quot;); // 分隔線&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;// 印出t的內容&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;// 印出資料 會印出 0 到 100&nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;for(int i = 0 ; i &lt;t.getSize() ;i++){<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf(&quot;%d\\n&quot;,t.getDataFromIndex(i));<br />\r\n&nbsp;&nbsp; &nbsp;}<br />\r\n}</p>\r\n\r\n<p>另外值得一提的是，我的排序是用 Merge Sort 排的，比起Bubble Sort使用了O( n ^ 2 )，Merge Sort只需要 O( nlog( n ) ) 。</p>\r\n\r\n<p>至於怎麼實現的，請參考 https://www.geeksforgeeks.org/merge-sort-for-linked-list/<br />\r\n想試試看自己寫的是否為正確，可以上&nbsp;https://leetcode.com/problems/sort-list/ 測試</p>",
        "attach": null,
        "rcount": null,
        "rank": null,
        "hit": "67",
        "lang": "1"
    }
}