{
    "data": {
        "@version": "3.0",
        "@time": "2024-07-19 08:53:45",
        "@type": "post",
        "@filename": "b000000002.xml",
        "open_time": "0000-00-00",
        "close_time": "0000-00-00",
        "lang_name": "Big5",
        "board_id": "1001296419",
        "node": "000000002",
        "site": "1000110001",
        "pt": "2023-10-03 16:26:09",
        "poster": "11127137",
        "realname": "黃乙家",
        "email": "u810025@gmail.com",
        "homepage": "https://ja-errorpro.cf",
        "subject": "115",
        "content": "<p><strong><span style=\"font-size:16px\">傳入陣列A和整數S，寫出C++函數從A找三個數字加總為S的組合。</span></strong></p>\r\n\r\n<p>這題可以對應到Leetcode 的 3sum 以及 3sum Closest 兩題</p>\r\n\r\n<p><a href=\"https://leetcode.com/problems/3sum/\">https://leetcode.com/problems/3sum/</a></p>\r\n\r\n<p><a href=\"https://leetcode.com/problems/3sum-closest/\">https://leetcode.com/problems/3sum-closest/</a></p>\r\n\r\n<p>假設要找的組合不能有重複的，先排序好陣列後會比較好做</p>\r\n\r\n<p>第一種作法是排序好後開三層迴圈直接暴力搜尋(Brute Force)</p>\r\n\r\n<p>```cpp</p>\r\n\r\n<p>vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums, int target) { // Brute Force</p>\r\n\r\n<p>&nbsp; &nbsp; if (nums.empty() || nums.size() &lt; 3) // 不到三個數字，沒有答案</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; return {};</p>\r\n\r\n<p>&nbsp; &nbsp; int n = nums.size();</p>\r\n\r\n<p>&nbsp; &nbsp; sort(nums.begin(), nums.end()); // 先排序好 平均：O(nlgn)，最差：O(n^2)</p>\r\n\r\n<p>&nbsp; &nbsp; vector&lt;vector&lt;int&gt;&gt; ret;</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; n - 2; i++) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; if (i == 0 || nums[i] != nums[i - 1]) { // 去掉重複的數字</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; for (int j = i + 1; j &lt; n - 1; j++) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (j == i + 1 || nums[j] != nums[j - 1]) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int k = j + 1; k &lt; n; k++) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (k == j + 1 || nums[k] != nums[k - 1]) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nums[i] + nums[j] + nums[k] == target) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret.push_back({nums[i], nums[j], nums[k]});</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; return ret;</p>\r\n\r\n<p>&nbsp; }</p>\r\n\r\n<p>```</p>\r\n\r\n<p>時間複雜度為 <img alt=\"O(N^3)\" src=\"https://latex.codecogs.com/gif.latex?O%28N%5E3%29\" /></p>\r\n\r\n<p>第二種作法沿用第一種，但使用hash table輔助搜尋，先將所有元素放入hash&nbsp;table，然後暴力枚舉取兩數，假設叫 <img alt=\"a, b\" src=\"https://latex.codecogs.com/gif.latex?a%2C%20b\" />，那麼就可以直接用 <img alt=\"O(1)\" src=\"https://latex.codecogs.com/gif.latex?O%281%29\" /> 的時間看<img alt=\"target - ( a+b )\" src=\"https://latex.codecogs.com/gif.latex?target%20-%20%28%20a&amp;plus;b%20%29\" /> 是否有在hash table裡，比直接暴力搜尋還快一個N</p>\r\n\r\n<p>```cpp</p>\r\n\r\n<p>vector&lt;vector&lt;int&gt;&gt; threeSum2(vector&lt;int&gt; &amp;nums,</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int target) { // hash table</p>\r\n\r\n<p>&nbsp; &nbsp; if (nums.empty() || nums.size() &lt; 3)</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; return {};</p>\r\n\r\n<p>&nbsp; &nbsp; int n = nums.size();</p>\r\n\r\n<p>&nbsp; &nbsp; sort(nums.begin(), nums.end());</p>\r\n\r\n<p>&nbsp; &nbsp; vector&lt;vector&lt;int&gt;&gt; ret;</p>\r\n\r\n<p>&nbsp; &nbsp; unordered_map&lt;int, int&gt; mp; // hash table</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; n; i++) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; mp[nums[i]] = i;</p>\r\n\r\n<p>&nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; n - 2; i++) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; if (i == 0 || nums[i] != nums[i - 1]) { // 去掉重複的數字</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; for (int j = i + 1; j &lt; n - 1; j++) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (j == i + 1 || nums[j] != nums[j - 1]) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int t = target - nums[i] - nums[j];</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mp.find(t) != mp.end() &amp;&amp; mp[t] &gt; j) { // 找到且不重複</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret.push_back({nums[i], nums[j], t});</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; return ret;</p>\r\n\r\n<p>&nbsp; }</p>\r\n\r\n<p>```</p>\r\n\r\n<p>時間複雜度為 <img alt=\"O(N^2)\" src=\"https://latex.codecogs.com/gif.latex?O%28N%5E2%29\" /></p>\r\n\r\n<p>第三種作法使用 Two Pointers(雙指針)，排序後先固定好陣列中一個數，接著定好左右界(<img alt=\"l, r, i \\le l \\le r\" src=\"https://latex.codecogs.com/gif.latex?l%2C%20r%2C%20i%20%5Cle%20l%20%5Cle%20r\" />)，如果 <img alt=\"array[i] + array[l] + array[r]\" src=\"https://latex.codecogs.com/gif.latex?array%5Bi%5D%20&amp;plus;%20array%5Bl%5D%20&amp;plus;%20array%5Br%5D\" /> 比目標還大，表示需要取更小的值，右界要往左移動，反之如果比目標小，表示需要取更大的值，左界往右移動，接著只要陣列的每個數字都固定一次( <img alt=\"O(N)\" src=\"https://latex.codecogs.com/gif.latex?O%28N%29\" /> )，接著雙指針跑一遍 (<img alt=\"O(N)\" src=\"https://latex.codecogs.com/gif.latex?O%28N%29\" />) 就能找出所有組合，加上排序複雜度最差情況是 <img alt=\"O(N^2)\" src=\"https://latex.codecogs.com/gif.latex?O%28N%5E2%29\" />，總複雜度 <img alt=\"= O ( N^2 + N^2 ) = O( N^2 )\" src=\"https://latex.codecogs.com/gif.latex?%3D%20O%20%28%20N%5E2%20&amp;plus;%20N%5E2%20%29%20%3D%20O%28%20N%5E2%20%29\" /></p>\r\n\r\n<p>```cpp</p>\r\n\r\n<p>vector&lt;vector&lt;int&gt;&gt; threeSum3(vector&lt;int&gt; &amp;nums,</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int target) { // Two Pointers, O(n^2)</p>\r\n\r\n<p>&nbsp; &nbsp; if (nums.empty() || nums.size() &lt; 3)</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; return {};</p>\r\n\r\n<p>&nbsp; &nbsp; int n = nums.size();</p>\r\n\r\n<p>&nbsp; &nbsp; sort(nums.begin(), nums.end());</p>\r\n\r\n<p>&nbsp; &nbsp; vector&lt;vector&lt;int&gt;&gt; ret;</p>\r\n\r\n<p>&nbsp; &nbsp; for (int i = 0; i &lt; n - 2; i++) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; if (i == 0 || nums[i] != nums[i - 1]) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; int l = i + 1, r = n - 1;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; while (l &lt; r) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nums[i] + nums[l] + nums[r] == target) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret.push_back({nums[i], nums[l], nums[r]});</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) // 去掉重複的數字</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l++;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1])</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r--;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l++;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r--;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (nums[i] + nums[l] + nums[r] &lt; target) {</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l++;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r--;</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; }</p>\r\n\r\n<p>&nbsp; &nbsp; return ret;</p>\r\n\r\n<p>&nbsp; }</p>\r\n\r\n<p>```</p>\r\n\r\n<p>最後我隨機生一筆 N = 1000 的測資並測量執行時間，得到以下結果(編譯器為 g++ (MinGW-W64), C++11)</p>\r\n\r\n<p>Brute Force : 0.712229<br />\r\nHash table : 0.024005<br />\r\nTwo Pointers : 0.004116</p>\r\n\r\n<p>(單位：秒)</p>\r\n\r\n<p>附檔為完整測試程式碼以及測資</p>",
        "attach": "115.cpp\tWM651bd0032b9ec.cpp\tinput.txt\tWM651bd00349eec.txt",
        "rcount": null,
        "rank": null,
        "hit": "44",
        "lang": "1"
    }
}