[
    {
        "question": "相同搜尋鍵的二筆資料如何存入二元搜尋樹？",
        "student_answer": "三筆資料",
        "reference_answer": [
            "在二元搜尋樹中，若出現相同搜尋鍵，通常將新資料插入右子樹或設計為允許重複鍵的樹。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "相同搜尋鍵的二筆資料如何存入二元搜尋樹？",
        "student_answer": "直接插入根就可將相同搜尋鍵存入二元樹。",
        "reference_answer": [
            "在二元搜尋樹中，若出現相同搜尋鍵，通常將新資料插入右子樹或設計為允許重複鍵的樹。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "相同搜尋鍵的二筆資料如何存入二元搜尋樹？",
        "student_answer": "若有遇到相同的搜尋鍵時，還是可將資料放入右子樹",
        "reference_answer": [
            "在二元搜尋樹中，若出現相同搜尋鍵，通常將新資料插入右子樹或設計為允許重複鍵的樹。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "相同搜尋鍵的二筆資料如何存入二元搜尋樹？",
        "student_answer": "若有相同當遇到相同的搜尋鍵時，可在該節點增加一個鏈表，將相同鍵值的資料存放在鏈表中，或插入右子樹。",
        "reference_answer": [
            "在二元搜尋樹中，若出現相同搜尋鍵，通常將新資料插入右子樹或設計為允許重複鍵的樹。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "已排序資料如何建立一棵平衡的二元搜尋樹？",
        "student_answer": "回答正確即可",
        "reference_answer": [
            "將已排序的資料中位數作為根節點，將左半部分資料作為左子樹，右半部分作為右子樹，遞迴重複此過程，即可建立平衡的二元搜尋樹。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "已排序資料如何建立一棵平衡的二元搜尋樹？",
        "student_answer": "可使用迴圈程式協助建立",
        "reference_answer": [
            "將已排序的資料中位數作為根節點，將左半部分資料作為左子樹，右半部分作為右子樹，遞迴重複此過程，即可建立平衡的二元搜尋樹。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "已排序資料如何建立一棵平衡的二元搜尋樹？",
        "student_answer": "可選擇中間元素作為根節點，剩下元素分別建成左右子樹。",
        "reference_answer": [
            "將已排序的資料中位數作為根節點，將左半部分資料作為左子樹，右半部分作為右子樹，遞迴重複此過程，即可建立平衡的二元搜尋樹。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "已排序資料如何建立一棵平衡的二元搜尋樹？",
        "student_answer": "選擇中間元素作為根節點，遞迴構建左子樹與右子樹。",
        "reference_answer": [
            "將已排序的資料中位數作為根節點，將左半部分資料作為左子樹，右半部分作為右子樹，遞迴重複此過程，即可建立平衡的二元搜尋樹。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "舉例說明如何為二元搜尋樹刪除節點。",
        "student_answer": "很有趣的問題",
        "reference_answer": [
            "刪除二元搜尋樹節點有三種情況：1. 無子節點，直接刪除。2. 一個子節點，用子節點替代。3. 兩個子節點，用後繼節點替代。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "舉例說明如何為二元搜尋樹刪除節點。",
        "student_answer": "若為根節點可馬上刪除",
        "reference_answer": [
            "刪除二元搜尋樹節點有三種情況：1. 無子節點，直接刪除。2. 一個子節點，用子節點替代。3. 兩個子節點，用後繼節點替代。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "舉例說明如何為二元搜尋樹刪除節點。",
        "student_answer": "若要刪除的節點後還有一個節點，要用這個子節點代替被刪除的節點。",
        "reference_answer": [
            "刪除二元搜尋樹節點有三種情況：1. 無子節點，直接刪除。2. 一個子節點，用子節點替代。3. 兩個子節點，用後繼節點替代。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "舉例說明如何為二元搜尋樹刪除節點。",
        "student_answer": "如果要刪除的節點沒有子節點時，直接刪除該節點。如果要刪除的節點有一個子節點時，用其子節點替代它。如果要刪除的節點有兩個子節點時，在其左子樹中找出最大的節點替代它，在其右子樹中找出最小的節點替代它。",
        "reference_answer": [
            "刪除二元搜尋樹節點有三種情況：1. 無子節點，直接刪除。2. 一個子節點，用子節點替代。3. 兩個子節點，用後繼節點替代。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "簡短說明二元搜尋樹和堆積(heap)的差異。",
        "student_answer": "狗跟貓咪的不同在於柔軟度。貓可以跳比較高且身體靈活。",
        "reference_answer": [
            "二元搜尋樹是按大小排序的樹結構，左子樹小於根，右子樹大於根；堆積則是一種完全二元樹，根節點是最大或最小值。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "簡短說明二元搜尋樹和堆積(heap)的差異。",
        "student_answer": "二元搜尋樹的左節點一定小於右節點，堆積則否。",
        "reference_answer": [
            "二元搜尋樹是按大小排序的樹結構，左子樹小於根，右子樹大於根；堆積則是一種完全二元樹，根節點是最大或最小值。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "簡短說明二元搜尋樹和堆積(heap)的差異。",
        "student_answer": "二元搜尋樹案大小排列，堆積則是完全二元樹。",
        "reference_answer": [
            "二元搜尋樹是按大小排序的樹結構，左子樹小於根，右子樹大於根；堆積則是一種完全二元樹，根節點是最大或最小值。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "簡短說明二元搜尋樹和堆積(heap)的差異。",
        "student_answer": "二元搜尋樹的左節點一定小於右節點，堆積則是根節點一定是最大或最小值。",
        "reference_answer": [
            "二元搜尋樹是按大小排序的樹結構，左子樹小於根，右子樹大於根；堆積則是一種完全二元樹，根節點是最大或最小值。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "說明使用前序(preorder)、中序(inorder)及後序(postorder)如何走訪二元樹。",
        "student_answer": "回答三分謝謝。",
        "reference_answer": [
            "前序走訪是先訪問根節點，再訪左子樹，最後訪右子樹；中序走訪是先訪左子樹，再訪根節點，最後訪右子樹；後序走訪則是先訪左子樹，再訪右子樹，最後訪根節點。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "說明使用前序(preorder)、中序(inorder)及後序(postorder)如何走訪二元樹。",
        "student_answer": "三種走訪順序不同",
        "reference_answer": [
            "前序走訪是先訪問根節點，再訪左子樹，最後訪右子樹；中序走訪是先訪左子樹，再訪根節點，最後訪右子樹；後序走訪則是先訪左子樹，再訪右子樹，最後訪根節點。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "說明使用前序(preorder)、中序(inorder)及後序(postorder)如何走訪二元樹。",
        "student_answer": "前序的訪問順序為根左右，中序為左根右。",
        "reference_answer": [
            "前序走訪是先訪問根節點，再訪左子樹，最後訪右子樹；中序走訪是先訪左子樹，再訪根節點，最後訪右子樹；後序走訪則是先訪左子樹，再訪右子樹，最後訪根節點。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "說明使用前序(preorder)、中序(inorder)及後序(postorder)如何走訪二元樹。",
        "student_answer": "前序的訪問順序為根左右，中序為左根右，後序為左右根。",
        "reference_answer": [
            "前序走訪是先訪問根節點，再訪左子樹，最後訪右子樹；中序走訪是先訪左子樹，再訪根節點，最後訪右子樹；後序走訪則是先訪左子樹，再訪右子樹，最後訪根節點。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "說明使用中序走訪二元搜尋樹是否為穩定排序。",
        "student_answer": "請稱讚我",
        "reference_answer": [
            "中序走訪二元搜尋樹是穩定排序，因為遍歷結果會按鍵值的遞增順序輸出，且不改變相同鍵值的相對順序。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "說明使用中序走訪二元搜尋樹是否為穩定排序。",
        "student_answer": "不是穩定排序，因為中序對二元樹不可行。",
        "reference_answer": [
            "中序走訪二元搜尋樹是穩定排序，因為遍歷結果會按鍵值的遞增順序輸出，且不改變相同鍵值的相對順序。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "說明使用中序走訪二元搜尋樹是否為穩定排序。",
        "student_answer": "是穩定排序，因中序的走訪結果會按大小排序。",
        "reference_answer": [
            "中序走訪二元搜尋樹是穩定排序，因為遍歷結果會按鍵值的遞增順序輸出，且不改變相同鍵值的相對順序。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "說明使用中序走訪二元搜尋樹是否為穩定排序。",
        "student_answer": "是穩定排序，因為對於相同值的節點，原本的相對位置會被保留，因此中序走訪是穩定排序。",
        "reference_answer": [
            "中序走訪二元搜尋樹是穩定排序，因為遍歷結果會按鍵值的遞增順序輸出，且不改變相同鍵值的相對順序。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "如果ptrX是鏈結串列中的一個節點，請說明ptrX = ptrX->next和ptrX->next = ptrX有什麼不同。",
        "student_answer": "是穩定排序。",
        "reference_answer": [
            "ptrX = ptrX->next 將 ptrX 移動到下一個節點；而 ptrX->next = ptrX 將當前節點的下一個指向自己，可能導致循環鏈結。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "如果ptrX是鏈結串列中的一個節點，請說明ptrX = ptrX->next和ptrX->next = ptrX有什麼不同。",
        "student_answer": "兩種指標方式差異在於第一個next在前，第二個next在後，但影響不大。",
        "reference_answer": [
            "ptrX = ptrX->next 將 ptrX 移動到下一個節點；而 ptrX->next = ptrX 將當前節點的下一個指向自己，可能導致循環鏈結。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "如果ptrX是鏈結串列中的一個節點，請說明ptrX = ptrX->next和ptrX->next = ptrX有什麼不同。",
        "student_answer": "第一種是將指標指向指標的下一個節點，第二種是將指標的下一個節點指向自己。",
        "reference_answer": [
            "ptrX = ptrX->next 將 ptrX 移動到下一個節點；而 ptrX->next = ptrX 將當前節點的下一個指向自己，可能導致循環鏈結。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "如果ptrX是鏈結串列中的一個節點，請說明ptrX = ptrX->next和ptrX->next = ptrX有什麼不同。",
        "student_answer": "第一種是將指標指向指標的下一個節點，不會影響原本結構。第二種是將指標的下一個節點指向自己，形成循環。",
        "reference_answer": [
            "ptrX = ptrX->next 將 ptrX 移動到下一個節點；而 ptrX->next = ptrX 將當前節點的下一個指向自己，可能導致循環鏈結。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "如何釋放指標所指向的記憶體？",
        "student_answer": "選擇中間元素作為根節點，遞迴構建左子樹與右子樹。",
        "reference_answer": [
            "要釋放指標指向的記憶體，可以使用 free() 函數。首先確認指標不為 NULL，然後呼叫 free(指標)，這樣就能釋放指標所佔用的記憶體空間。",
            "使用delete釋放指標所指向的記憶體，若是陣列則用delete[]。記憶體釋放後應將指標設為nullptr，避免野指標問題。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "如何釋放指標所指向的記憶體？",
        "student_answer": "使指標為null，即可釋放。",
        "reference_answer": [
            "要釋放指標指向的記憶體，可以使用 free() 函數。首先確認指標不為 NULL，然後呼叫 free(指標)，這樣就能釋放指標所佔用的記憶體空間。",
            "使用delete釋放指標所指向的記憶體，若是陣列則用delete[]。記憶體釋放後應將指標設為nullptr，避免野指標問題。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "如何釋放指標所指向的記憶體？",
        "student_answer": "可使用free()函數釋放記憶體。",
        "reference_answer": [
            "要釋放指標指向的記憶體，可以使用 free() 函數。首先確認指標不為 NULL，然後呼叫 free(指標)，這樣就能釋放指標所佔用的記憶體空間。",
            "使用delete釋放指標所指向的記憶體，若是陣列則用delete[]。記憶體釋放後應將指標設為nullptr，避免野指標問題。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "如何釋放指標所指向的記憶體？",
        "student_answer": "確認指標不為NULL後可使用free()函數釋放記憶體，釋放後記得將指標指向null，避免其他問題。",
        "reference_answer": [
            "要釋放指標指向的記憶體，可以使用 free() 函數。首先確認指標不為NULL，然後呼叫 free(指標)，這樣就能釋放指標所佔用的記憶體空間。",
            "使用delete釋放指標所指向的記憶體，若是陣列則用delete[]。記憶體釋放後應將指標設為nullptr，避免野指標問題。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "請舉一個適合使用環狀鏈結串列(Circularly linked list)的例子。",
        "student_answer": "不告訴你，自己回答。",
        "reference_answer": [
            "環狀鏈結串列適合用於音樂播放器的播放清單，因為可以不斷循環播放歌曲，當到達最後一首歌時，自動返回到第一首實現循環播放的功能。",
            "適合使用環狀鏈結串列的例子是多人遊戲中的輪流操作系統，因為它可以不斷循環每個玩家的回合。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "請舉一個適合使用環狀鏈結串列(Circularly linked list)的例子。",
        "student_answer": "瀏覽器的前進和後退按鈕適合使用環狀鏈結串列。",
        "reference_answer": [
            "環狀鏈結串列適合用於音樂播放器的播放清單，因為可以不斷循環播放歌曲，當到達最後一首歌時，自動返回到第一首實現循環播放的功能。",
            "適合使用環狀鏈結串列的例子是多人遊戲中的輪流操作系統，因為它可以不斷循環每個玩家的回合。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "請舉一個適合使用環狀鏈結串列(Circularly linked list)的例子。",
        "student_answer": "重播音樂清單適合使用環狀鏈結串列。",
        "reference_answer": [
            "環狀鏈結串列適合用於音樂播放器的播放清單，因為可以不斷循環播放歌曲，當到達最後一首歌時，自動返回到第一首實現循環播放的功能。",
            "適合使用環狀鏈結串列的例子是多人遊戲中的輪流操作系統，因為它可以不斷循環每個玩家的回合。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "請舉一個適合使用環狀鏈結串列(Circularly linked list)的例子。",
        "student_answer": "玩抽鬼牌時，玩家要輪流抽取其他人的牌，每回合不斷循環，適合使用環狀鏈結串列。",
        "reference_answer": [
            "環狀鏈結串列適合用於音樂播放器的播放清單，因為可以不斷循環播放歌曲，當到達最後一首歌時，自動返回到第一首實現循環播放的功能。",
            "適合使用環狀鏈結串列的例子是多人遊戲中的輪流操作系統，因為它可以不斷循環每個玩家的回合。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "什麼是空指標(null pointer)？",
        "student_answer": "可能跟佇列有關，都很複雜。",
        "reference_answer": [
            "空指標（null pointer）是一種不指向任何有效記憶體位置的指標，通常用來表示指標未初始化或不指向任何物件。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "什麼是空指標(null pointer)？",
        "student_answer": "就是=null。",
        "reference_answer": [
            "空指標（null pointer）是一種不指向任何有效記憶體位置的指標，通常用來表示指標未初始化或不指向任何物件。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "什麼是空指標(null pointer)？",
        "student_answer": "就是不指向任何東西的指標。",
        "reference_answer": [
            "空指標（null pointer）是一種不指向任何有效記憶體位置的指標，通常用來表示指標未初始化或不指向任何物件。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "什麼是空指標(null pointer)？",
        "student_answer": "就是不指向任何東西的指標，可以用來表示指標未初始化。",
        "reference_answer": [
            "空指標（null pointer）是一種不指向任何有效記憶體位置的指標，通常用來表示指標未初始化或不指向任何物件。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "為什麼雙向鏈結串列在某些情況下效率比單向鏈結串列更高？",
        "student_answer": "颱風終於走了。",
        "reference_answer": [
            "雙向鏈結串列可以從兩個方向進行遍歷，讓刪除或插入操作更快，尤其當需要訪問前一個節點時，比單向鏈結串列更有效率。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "為什麼雙向鏈結串列在某些情況下效率比單向鏈結串列更高？",
        "student_answer": "雙向鏈結在任何情況都比單項鏈結快，這是一個常見的優點。",
        "reference_answer": [
            "雙向鏈結串列可以從兩個方向進行遍歷，讓刪除或插入操作更快，尤其當需要訪問前一個節點時，比單向鏈結串列更有效率。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "為什麼雙向鏈結串列在某些情況下效率比單向鏈結串列更高？",
        "student_answer": "因為雙向鏈結串列的頭跟尾都可以進行訪問。",
        "reference_answer": [
            "雙向鏈結串列可以從兩個方向進行遍歷，讓刪除或插入操作更快，尤其當需要訪問前一個節點時，比單向鏈結串列更有效率。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "為什麼雙向鏈結串列在某些情況下效率比單向鏈結串列更高？",
        "student_answer": "因為雙向鏈結串列的每個節點都有指向前後節點的指標，所以在插入或刪除節點時，可以更快地找到前後節點。",
        "reference_answer": [
            "雙向鏈結串列可以從兩個方向進行遍歷，讓刪除或插入操作更快，尤其當需要訪問前一個節點時，比單向鏈結串列更有效率。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "簡短說明整數溢位(integer overflow)的避免方法。",
        "student_answer": "不知道我不會",
        "reference_answer": [
            "為了避免整數溢位，可以使用較大範圍的資料型別，如`long`或`BigInteger`，來儲存可能超過基本整數範圍的數字。此外，實施邊界檢查，確保在運算前確認數值不會導致溢位也是有效的方法。`long`或`BigInteger`，來存儲可能超過基本整數範圍的數字。此外，實施邊界檢查，確保在運算前確認數值不會導致溢位也是有效的方法。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "簡短說明整數溢位(integer overflow)的避免方法。",
        "student_answer": "整數溢位可以透過減少數字大小或加大儲存空間來避免。",
        "reference_answer": [
            "為了避免整數溢位，可以使用較大範圍的資料型別，如`long`或`BigInteger`，來存儲可能超過基本整數範圍的數字。此外，實施邊界檢查，確保在運算前確認數為了避免整數溢位，可以使用較大範圍的資料型別，如`long`或`BigInteger`，來儲存可能超過基本整數範圍的數字。此外，實施邊界檢查，確保在運算前確認數值不會導致溢位也是有效的方法。值不會導致溢位也是有效的方法。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "簡短說明整數溢位(integer overflow)的避免方法。",
        "student_answer": "整數溢位可以透過使用較大範圍的資料型別、在運算前檢查數值範圍，或使用程式語言內建的溢位檢查工具來避免。",
        "reference_answer": [
            "為了避免整數溢位，可以使用較大範圍的資料型別，如`long`或`BigInteger`，來儲存可能超過基本整數範圍的數字。此外，實施邊界檢查，確保在運算前確認數值不會導致溢位也是有效的方法。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "簡短說明整數溢位(integer overflow)的避免方法。",
        "student_answer": "整數溢位發生在數值超過資料型別的範圍時，導致錯誤結果。避免方法包括：使用較大範圍的資料型別（如從 int 換成 long）、在運算前檢查數值是否接近型別限制、或使用語言內建的溢位檢查功能，如 C# 的 checked 來捕捉溢位情況。",
        "reference_answer": [
            "為了避免整數溢位，可以使用較大範圍的資料型別，如`long`或`BigInteger`，來儲存可能超過基本整數範圍的數字。此外，實施邊界檢查，確保在運算前確認數值不會導致溢位也是有效的方法。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "請簡短說明Overloading。",
        "student_answer": "太難了",
        "reference_answer": [
            "Overloading 是指在程式設計中允許同名函數有不同參數類型或數量。方便提高程式彈性與可讀性。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "請簡短說明Overloading。",
        "student_answer": "子類別可以繼承父類別的屬性和方法",
        "reference_answer": [
            "Overloading 是指在程式設計中允許同名函數有不同參數類型或數量。方便提高程式彈性與可讀性。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "請簡短說明Overloading。",
        "student_answer": "同一個函式或運算符根據不同的參數類型或數量執行不同的操作",
        "reference_answer": [
            "Overloading 是指在程式設計中允許同名函數有不同參數類型或數量。方便提高程式彈性與可讀性。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "請簡短說明Overloading。",
        "student_answer": "Overloading 是指在程式設計中允許同名函數有不同參數類型或數量。",
        "reference_answer": [
            "Overloading 是指在程式設計中允許同名函數有不同參數類型或數量。方便提高程式彈性與可讀性。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "請簡短說明繼承(inheritance)。",
        "student_answer": "看不懂題目",
        "reference_answer": [
            "繼承是一種面向物件編程的概念，指的是一個類別可以繼承另一個類別的屬性和方法，從而建立父類別和子類別的關係。子類別繼承父類別的所有成員（屬性和方法），並可以新增或覆寫父類別的成員。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "請簡短說明繼承(inheritance)。",
        "student_answer": "同一個函式或運算符根據不同的參數類型或數量執行不同的操作",
        "reference_answer": [
            "繼承是一種面向物件編程的概念，指的是一個類別可以繼承另一個類別的屬性和方法，從而建立父類別和子類別的關係。子類別繼承父類別的所有成員（屬性和方法），並可以新增或覆寫父類別的成員。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "請簡短說明繼承(inheritance)。",
        "student_answer": "繼承是一種讓子類別繼承父類別屬性和方法的機制，讓程式碼重複使用更方便。",
        "reference_answer": [
            "繼承是一種面向物件編程的概念，指的是一個類別可以繼承另一個類別的屬性和方法，從而建立父類別和子類別的關係。子類別繼承父類別的所有成員（屬性和方法），並可以新增或覆寫父類別的成員。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "請簡短說明繼承(inheritance)。",
        "student_answer": "繼承是指子類別可以繼承父類別的屬性和方法，並可以新增或覆寫父類別的成員，實現程式碼重複利用和擴展功能。",
        "reference_answer": [
            "繼承是一種面向物件編程的概念，指的是一個類別可以繼承另一個類別的屬性和方法，從而建立父類別和子類別的關係。子類別繼承父類別的所有成員（屬性和方法），並可以新增或覆寫父類別的成員。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "請簡短說明傳值呼叫(call by value)。",
        "student_answer": "我不會",
        "reference_answer": [
            "傳值呼叫是指在函數呼叫時，將變數的值複製一份再傳入函數中。在函數內部對變數的改變不會影響到外部的原始變數，確保了原始資料的安全但可能增加記憶體使用。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "請簡短說明傳值呼叫(call by value)。",
        "student_answer": "在函式中傳遞變數的地址，允許函數直接修改原變數的值",
        "reference_answer": [
            "傳值呼叫是指在函數呼叫時，將變數的值複製一份再傳入函數中。在函數內部對變數的改變不會影響到外部的原始變數，確保了原始資料的安全但可能增加記憶體使用。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "請簡短說明傳值呼叫(call by value)。",
        "student_answer": "傳值呼叫是指在函數呼叫時，將變數的值複製一份再傳入函數中",
        "reference_answer": [
            "傳值呼叫是指在函數呼叫時，將變數的值複製一份再傳入函數中。在函數內部對變數的改變不會影響到外部的原始變數，確保了原始資料的安全但可能增加記憶體使用。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "請簡短說明傳值呼叫(call by value)。",
        "student_answer": "傳值呼叫是把參數的複製品傳給函式，函式內修改只影響這個複製品，不會改變原來變數的值或狀態。",
        "reference_answer": [
            "傳值呼叫是指在函數呼叫時，將變數的值複製一份再傳入函數中。在函數內部對變數的改變不會影響到外部的原始變數，確保了原始資料的安全但可能增加記憶體使用。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "以自己的話描述遞迴(recursion)是什麼。",
        "student_answer": "不知道",
        "reference_answer": [
            "遞迴是函式自己呼叫自己的概念，通常用來解決可以分成相似子問題的大問題，直到達到初始情況停止。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "以自己的話描述遞迴(recursion)是什麼。",
        "student_answer": "重複執行某段程式碼，用條件控制結束",
        "reference_answer": [
            "遞迴是函式自己呼叫自己的概念，通常用來解決可以分成相似子問題的大問題，直到達到初始情況停止。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "以自己的話描述遞迴(recursion)是什麼。",
        "student_answer": "大問題切成很多一樣的小問題",
        "reference_answer": [
            "遞迴是函式自己呼叫自己的概念，通常用來解決可以分成相似子問題的大問題，直到達到初始情況停止。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "以自己的話描述遞迴(recursion)是什麼。",
        "student_answer": "大問題切成很多一樣的小問題，讓程式可以重複執行自己，直到滿足某個條件為止。",
        "reference_answer": [
            "遞迴是函式自己呼叫自己的概念，通常用來解決可以分成相似子問題的大問題，直到達到初始情況停止。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "什麼情況下適合使用遞迴？為什麼？",
        "student_answer": "任何時候都可以使用遞迴",
        "reference_answer": [
            "當問題可以被分解為相似的小問題，且有明確的結束條件時，適合使用遞迴，因為它能簡化程式邏輯。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "什麼情況下適合使用遞迴？為什麼？",
        "student_answer": "當問題可以被分解為相似的小問題",
        "reference_answer": [
            "當問題可以被分解為相似的小問題，且有明確的結束條件時，適合使用遞迴，因為它能簡化程式邏輯。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "什麼情況下適合使用遞迴？為什麼？",
        "student_answer": "當問題能被分解為相似的子問題時適合使用遞迴，因為遞迴能讓程式簡潔易懂。",
        "reference_answer": [
            "當問題可以被分解為相似的小問題，且有明確的結束條件時，適合使用遞迴，因為它能簡化程式邏輯。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "什麼情況下適合使用遞迴？為什麼？",
        "student_answer": "當問題可以分解成相同的子問題且有明確的結束條件時，適合使用遞迴",
        "reference_answer": [
            "當問題可以被分解為相似的小問題，且有明確的結束條件時，適合使用遞迴，因為它能簡化程式邏輯。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "遞迴(recursion)和迴圈(interative)的區別是什麼？",
        "student_answer": "不知道",
        "reference_answer": [
            "遞迴是函數自己呼叫自己，直到滿足終止條件，適合分解問題。迴圈則是重複執行某段程式碼，用條件控制結束。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "遞迴(recursion)和迴圈(interative)的區別是什麼？",
        "student_answer": "遞迴是重複執行某段程式碼，用條件控制結束，迴圈是函數自己呼叫自己，直到滿足終止條件。",
        "reference_answer": [
            "遞迴是函數自己呼叫自己，直到滿足終止條件，適合分解問題。迴圈則是重複執行某段程式碼，用條件控制結束。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "遞迴(recursion)和迴圈(interative)的區別是什麼？",
        "student_answer": "遞迴是函數自己呼叫自己。迴圈則是重複執行某段程式碼。",
        "reference_answer": [
            "遞迴是函數自己呼叫自己，直到滿足終止條件，適合分解問題。迴圈則是重複執行某段程式碼，用條件控制結束。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "遞迴(recursion)和迴圈(interative)的區別是什麼？",
        "student_answer": "遞迴是指函數不斷呼叫自己，直到符合終止條件，適合用來分解問題。迴圈則是重複執行程式碼，並依照條件決定何時結束。",
        "reference_answer": [
            "遞迴是函數自己呼叫自己，直到滿足終止條件，適合分解問題。迴圈則是重複執行某段程式碼，用條件控制結束。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "堆疊(stack)的特性是什麼？",
        "student_answer": "不知道",
        "reference_answer": [
            "堆疊 (stack) 是一種後進先出 (LIFO) 的資料結構，最後放入的元素最先取出。"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "堆疊(stack)的特性是什麼？",
        "student_answer": "堆疊 (stack) 是一種先進先出 (FIFO)",
        "reference_answer": [
            "堆疊 (stack) 是一種後進先出 (LIFO) 的資料結構，最後放入的元素最先取出。"
        ],
        "score": "1",
        "comment": ""
    },
    {
        "question": "堆疊(stack)的特性是什麼？",
        "student_answer": "堆疊 (stack) 是一種後進先出 (LIFO)",
        "reference_answer": [
            "堆疊 (stack) 是一種後進先出 (LIFO) 的資料結構，最後放入的元素最先取出。"
        ],
        "score": "2",
        "comment": ""
    },
    {
        "question": "堆疊(stack)的特性是什麼？",
        "student_answer": "堆疊（stack）是一種後進先出的資料結構，當資料加入或刪除時，都是作用在堆疊頂部操作。",
        "reference_answer": [
            "堆疊 (stack) 是一種後進先出 (LIFO) 的資料結構，最後放入的元素最先取出。"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "堆疊的時間複雜度是多少？",
        "student_answer": "n*log(n)",
        "reference_answer": [
            "O(1)"
        ],
        "score": "0",
        "comment": ""
    },
    {
        "question": "堆疊的時間複雜度是多少？",
        "student_answer": "O(1)",
        "reference_answer": [
            "O(1)"
        ],
        "score": "3",
        "comment": ""
    },
    {
        "question": "如何計算單一佇列的平均等候時間(waiting time)？",
        "student_answer": "是一種時間",
        "reference_answer": [
            "單一佇列的平均等候時間計算方式是：將每個任務的等候時間加總，再除以任務總數。公式：平均等候時間 = (總等候時間) / (任務數量)。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "如何計算單一佇列的平均等候時間(waiting time)？",
        "student_answer": "每個任務的執行時間總和。",
        "reference_answer": [
            "單一佇列的平均等候時間計算方式是：將每個任務的等候時間加總，再除以任務總數。公式：平均等候時間 = (總等候時間) / (任務數量)。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "如何計算單一佇列的平均等候時間(waiting time)？",
        "student_answer": "將所有任務的等待時間相加，然後平均。",
        "reference_answer": [
            "單一佇列的平均等候時間計算方式是：將每個任務的等候時間加總，再除以任務總數。公式：平均等候時間 = (總等候時間) / (任務數量)。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "如何計算單一佇列的平均等候時間(waiting time)？",
        "student_answer": "平均等候時間是將每個任務的等候時間加總，然後除以任務的數量。公式為：平均等候時間 = (總等候時間) / (任務數量)。",
        "reference_answer": [
            "單一佇列的平均等候時間計算方式是：將每個任務的等候時間加總，再除以任務總數。公式：平均等候時間 = (總等候時間) / (任務數量)。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "請說明雙重佇列如何模擬，並說明選擇佇列的策略是什麼。",
        "student_answer": "這題我不知道。",
        "reference_answer": [
            "雙重佇列模擬可用兩個獨立佇列處理不同優先級的任務。選擇策略常依優先級決定，優先處理高優先級佇列的任務。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "請說明雙重佇列如何模擬，並說明選擇佇列的策略是什麼。",
        "student_answer": "雙重佇列是佇列的特殊形式",
        "reference_answer": [
            "雙重佇列模擬可用兩個獨立佇列處理不同優先級的任務。選擇策略常依優先級決定，優先處理高優先級佇列的任務。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "請說明雙重佇列如何模擬，並說明選擇佇列的策略是什麼。",
        "student_answer": "雙重佇列是用來處理不同優先級的任務。",
        "reference_answer": [
            "雙重佇列模擬可用兩個獨立佇列處理不同優先級的任務。選擇策略常依優先級決定，優先處理高優先級佇列的任務。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "請說明雙重佇列如何模擬，並說明選擇佇列的策略是什麼。",
        "student_answer": "雙重佇列是指系統中同時存在兩個佇列，分別用來處理不同優先級或特性的任務，用來平衡兩個佇列。選擇策略可根據不同系統的需求和特性進行選擇或結合使用",
        "reference_answer": [
            "雙重佇列模擬可用兩個獨立佇列處理不同優先級的任務。選擇策略常依優先級決定，優先處理高優先級佇列的任務。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "比較佇列(Queue)和堆疊(Stack)的不同之處。",
        "student_answer": "很棒",
        "reference_answer": [
            "佇列是先進先出（FIFO），最先加入的元素最先移除；堆疊是後進先出（LIFO），最後加入的元素最先移除。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "比較佇列(Queue)和堆疊(Stack)的不同之處。",
        "student_answer": "佇列是後進先出，堆疊是先進先出。",
        "reference_answer": [
            "佇列是先進先出（FIFO），最先加入的元素最先移除；堆疊是後進先出（LIFO），最後加入的元素最先移除。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "比較佇列(Queue)和堆疊(Stack)的不同之處。",
        "student_answer": "佇列是先進先出，堆疊是後進先出。",
        "reference_answer": [
            "佇列是先進先出（FIFO），最先加入的元素最先移除；堆疊是後進先出（LIFO），最後加入的元素最先移除。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "比較佇列(Queue)和堆疊(Stack)的不同之處。",
        "student_answer": "都是基本的資料結構，差別在於佇列是先進先出，最先加入的元素會先被移除；堆疊是後進先出，最後加入的元素會最先移除。",
        "reference_answer": [
            "佇列是先進先出（FIFO），最先加入的元素最先移除；堆疊是後進先出（LIFO），最後加入的元素最先移除。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "如何實現優先佇列(Priority Queue)？",
        "student_answer": "不能吧",
        "reference_answer": [
            "優先佇列可用heap實現，元素根據優先級插入，較高優先級的元素會先被取出。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "如何實現優先佇列(Priority Queue)？",
        "student_answer": "優先佇列是一種用來處理不同重要性任務的結構。",
        "reference_answer": [
            "優先佇列可用heap實現，元素根據優先級插入，較高優先級的元素會先被取出。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "如何實現優先佇列(Priority Queue)？",
        "student_answer": "優先佇列可以根據優先級來處理任務，使用 heap 來插入和取出元素。",
        "reference_answer": [
            "優先佇列可用heap實現，元素根據優先級插入，較高優先級的元素會先被取出。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "如何實現優先佇列(Priority Queue)？",
        "student_answer": "優先佇列可以通過使用 heap 來實現，根據每個元素的優先級進行插入，並且較高優先級的元素會先被取出。",
        "reference_answer": [
            "優先佇列可用heap實現，元素根據優先級插入，較高優先級的元素會先被取出。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "佇列(Queue)的基本操作有哪些？",
        "student_answer": "什麼是基本操作",
        "reference_answer": [
            "佇列的基本操作包括：enqueue將元素加入佇列尾端、dequeue移除第一個元素、front/peek檢查第一個元素和isEmpty檢查佇列是否為空。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "佇列(Queue)的基本操作有哪些？",
        "student_answer": "dequeue將加入元素。",
        "reference_answer": [
            "佇列的基本操作包括：enqueue將元素加入佇列尾端、dequeue移除第一個元素、front/peek檢查第一個元素和isEmpty檢查佇列是否為空。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "佇列(Queue)的基本操作有哪些？",
        "student_answer": "佇列可以加入元素並移除第一個元素。",
        "reference_answer": [
            "佇列的基本操作包括：enqueue將元素加入佇列尾端、dequeue移除第一個元素、front/peek檢查第一個元素和isEmpty檢查佇列是否為空。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "佇列(Queue)的基本操作有哪些？",
        "student_answer": "佇列的基本操作有：enqueue將元素加入尾端，dequeue移除第一個元素，front檢查第一個元素，isEmpty檢查佇列是否為空。",
        "reference_answer": [
            "佇列的基本操作包括：enqueue將元素加入佇列尾端、dequeue移除第一個元素、front/peek檢查第一個元素和isEmpty檢查佇列是否為空。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "說明氣泡排序(bubble sort)如何提早結束執行。",
        "student_answer": "跟泡泡有關",
        "reference_answer": [
            "氣泡排序可以透過在每一輪檢查是否有元素交換，若無交換，代表已經排序完成，提早結束排序，避免不必要的比較。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "說明氣泡排序(bubble sort)如何提早結束執行。",
        "student_answer": "氣泡排序會交換元素。",
        "reference_answer": [
            "氣泡排序可以透過在每一輪檢查是否有元素交換，若無交換，代表已經排序完成，提早結束排序，避免不必要的比較。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "說明氣泡排序(bubble sort)如何提早結束執行。",
        "student_answer": "透過在每一輪檢查是否有元素交換",
        "reference_answer": [
            "氣泡排序可以透過在每一輪檢查是否有元素交換，若無交換，代表已經排序完成，提早結束排序，避免不必要的比較。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "說明氣泡排序(bubble sort)如何提早結束執行。",
        "student_answer": "氣泡排序可以檢查是否有交換，如果沒有，就表示已經完成排序，可以提早結束。",
        "reference_answer": [
            "氣泡排序可以透過在每一輪檢查是否有元素交換，若無交換，代表已經排序完成，提早結束排序，避免不必要的比較。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "簡短說明選擇排序(selection sort)為什麼不是穩定排序。",
        "student_answer": "是不是一種選擇東西的方式",
        "reference_answer": [
            "選擇排序不是穩定排序，因為在選擇最小值時可能會交換不相鄰的相同元素，導致相同值的相對順序被改變，破壞穩定性。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "簡短說明選擇排序(selection sort)為什麼不是穩定排序。",
        "student_answer": "因為不相同的元素的關係",
        "reference_answer": [
            "選擇排序不是穩定排序，因為在選擇最小值時可能會交換不相鄰的相同元素，導致相同值的相對順序被改變，破壞穩定性。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "簡短說明選擇排序(selection sort)為什麼不是穩定排序。",
        "student_answer": "選擇排序不是穩定排序因為相同元素可能會被交換",
        "reference_answer": [
            "選擇排序不是穩定排序，因為在選擇最小值時可能會交換不相鄰的相同元素，導致相同值的相對順序被改變，破壞穩定性。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "簡短說明選擇排序(selection sort)為什麼不是穩定排序。",
        "student_answer": "選擇排序不是穩定排序，因為在選擇最小值時可能會交換不相鄰的相同元素，這會改變它們的相對順序。",
        "reference_answer": [
            "選擇排序不是穩定排序，因為在選擇最小值時可能會交換不相鄰的相同元素，導致相同值的相對順序被改變，破壞穩定性。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "請指出影響氣泡排序是否穩定的關鍵指令。",
        "student_answer": "沒辦法知道",
        "reference_answer": [
            "影響氣泡排序是否穩定的關鍵指令是「交換」，因為氣泡排序只交換相鄰元素，保持相同值的順序不變，所以是穩定排序。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "請指出影響氣泡排序是否穩定的關鍵指令。",
        "student_answer": "氣泡排序的選擇指令。",
        "reference_answer": [
            "影響氣泡排序是否穩定的關鍵指令是「交換」，因為氣泡排序只交換相鄰元素，保持相同值的順序不變，所以是穩定排序。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "請指出影響氣泡排序是否穩定的關鍵指令。",
        "student_answer": "影響穩定性的指令是交換，相鄰的元素會互相交換",
        "reference_answer": [
            "影響氣泡排序是否穩定的關鍵指令是「交換」，因為氣泡排序只交換相鄰元素，保持相同值的順序不變，所以是穩定排序。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "請指出影響氣泡排序是否穩定的關鍵指令。",
        "student_answer": "影響氣泡排序穩定性的指令是交換，因為氣泡排序只交換相鄰的元素，只要相同值不交換，相對順序就不變，因此它是穩定排序。",
        "reference_answer": [
            "影響氣泡排序是否穩定的關鍵指令是「交換」，因為氣泡排序只交換相鄰元素，保持相同值的順序不變，所以是穩定排序。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "比較氣泡排序和選擇排序的資料交換次數，何者較多？",
        "student_answer": "都是排序阿",
        "reference_answer": [
            "氣泡排序每次比較時都可能進行資料交換，而選擇排序每次比較後只進行一次資料交換。因此氣泡排序的資料交換次數一般遠多於選擇排序。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "比較氣泡排序和選擇排序的資料交換次數，何者較多？",
        "student_answer": "選擇排序的資料交換次數一般遠多於氣泡排序。",
        "reference_answer": [
            "氣泡排序每次比較時都可能進行資料交換，而選擇排序每次比較後只進行一次資料交換。因此氣泡排序的資料交換次數一般遠多於選擇排序。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "比較氣泡排序和選擇排序的資料交換次數，何者較多？",
        "student_answer": "氣泡排序的資料交換次數比選擇排序多",
        "reference_answer": [
            "氣泡排序每次比較時都可能進行資料交換，而選擇排序每次比較後只進行一次資料交換。因此氣泡排序的資料交換次數一般遠多於選擇排序。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "比較氣泡排序和選擇排序的資料交換次數，何者較多？",
        "student_answer": "氣泡排序的資料交換次數通常較多，因為它在每次比較時都可能進行多次交換，而選擇排序則是在每輪比較後只進行一次交換，因此氣泡排序的資料交換次數遠超過選擇排序。",
        "reference_answer": [
            "氣泡排序每次比較時都可能進行資料交換，而選擇排序每次比較後只進行一次資料交換。因此氣泡排序的資料交換次數一般遠多於選擇排序。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "簡短說明何時希爾排序的資料搬動次數比插入排序多？",
        "student_answer": "我看不懂",
        "reference_answer": [
            "當資料接近排序完成時，希爾排序的搬動次數可能比插入排序多，因為希爾排序仍需進行多次分組排序，而插入排序在幾乎排序好的情況下搬動較少。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "簡短說明何時希爾排序的資料搬動次數比插入排序多？",
        "student_answer": "當資料接近反序排列時，插入排序的資料搬動次數會比希爾排序多，因為插入排序必須逐一移動資料，而希爾排序可跳躍較大間隔排序。",
        "reference_answer": [
            "當資料接近排序完成時，希爾排序的搬動次數可能比插入排序多，因為希爾排序仍需進行多次分組排序，而插入排序在幾乎排序好的情況下搬動較少。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "簡短說明何時希爾排序的資料搬動次數比插入排序多？",
        "student_answer": "當資料幾乎已經排序完成的時候",
        "reference_answer": [
            "當資料接近排序完成時，希爾排序的搬動次數可能比插入排序多，因為希爾排序仍需進行多次分組排序，而插入排序在幾乎排序好的情況下搬動較少。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "簡短說明何時希爾排序的資料搬動次數比插入排序多？",
        "student_answer": "當資料幾乎已經排序完成的時候，希爾排序可能會比插入排序需要更多的搬動，因為希爾排序會分組處理，而插入排序的搬動次數會比較少。",
        "reference_answer": [
            "當資料接近排序完成時，希爾排序的搬動次數可能比插入排序多，因為希爾排序仍需進行多次分組排序，而插入排序在幾乎排序好的情況下搬動較少。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "簡短說明快速排序的遞迴深度會受何者影響。",
        "student_answer": "太難了",
        "reference_answer": [
            "快速排序的遞迴深度受選擇樞紐（pivot）的好壞影響，若樞紐選得不好，遞迴深度會加深。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "簡短說明快速排序的遞迴深度會受何者影響。",
        "student_answer": "受到資料分布的影響",
        "reference_answer": [
            "快速排序的遞迴深度受選擇樞紐（pivot）的好壞影響，若樞紐選得不好，遞迴深度會加深。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "簡短說明快速排序的遞迴深度會受何者影響。",
        "student_answer": "快速排序的遞迴深度會受到樞紐的選擇影響，若樞紐選擇不當，會導致遞迴深度過深。",
        "reference_answer": [
            "快速排序的遞迴深度受選擇樞紐（pivot）的好壞影響，若樞紐選得不好，遞迴深度會加深。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "簡短說明快速排序的遞迴深度會受何者影響。",
        "student_answer": "快速排序的遞迴深度會受選擇樞紐的影響，若樞紐選得不好，可能會造成不平衡的分割，使得遞迴深度增加，從而降低排序效率。好的樞紐能夠平衡左右兩邊的元素，減少遞迴深度。",
        "reference_answer": [
            "快速排序的遞迴深度受選擇樞紐（pivot）的好壞影響，若樞紐選得不好，遞迴深度會加深。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "簡短希爾排序為甚麼是不穩定排序。",
        "student_answer": "我不會",
        "reference_answer": [
            "希爾排序是不穩定排序，因為在進行較大間隔的排序時，可能會改變相同鍵值元素的相對順序，導致排序不穩定。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "簡短希爾排序為甚麼是不穩定排序。",
        "student_answer": "希爾排序是穩定的，因為它不會改變相同元素的順序。",
        "reference_answer": [
            "希爾排序是不穩定排序，因為在進行較大間隔的排序時，可能會改變相同鍵值元素的相對順序，導致排序不穩定。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "簡短希爾排序為甚麼是不穩定排序。",
        "student_answer": "希爾排序會改變相同鍵值元素的順序，因此是不穩定的。",
        "reference_answer": [
            "希爾排序是不穩定排序，因為在進行較大間隔的排序時，可能會改變相同鍵值元素的相對順序，導致排序不穩定。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "簡短希爾排序為甚麼是不穩定排序。",
        "student_answer": "希爾排序是不穩定排序，因為在進行較大間隔的排序時，可能會導致相同鍵值元素的相對順序改變，這使得排序不穩定。例如，當一個元素被插入到一個不同的組別時，可能會改變其原來的位置。",
        "reference_answer": [
            "希爾排序是不穩定排序，因為在進行較大間隔的排序時，可能會改變相同鍵值元素的相對順序，導致排序不穩定。"
        ],
        "score": "3",
        "comment": "不用填"
    },
    {
        "question": "為快速排序提出選擇樞紐(pivot)的方法，並簡短說明優點。",
        "student_answer": "天氣真好",
        "reference_answer": [
            "快速排序選擇基準（pivot）的方法有：使用首尾元素、隨機選取或三數取中法。隨機選取能避免最壞情況，三數取中法則能更平衡分割數組，提升效率。"
        ],
        "score": "0",
        "comment": "不用填"
    },
    {
        "question": "為快速排序提出選擇樞紐(pivot)的方法，並簡短說明優點。",
        "student_answer": "快速排序可以用隨機選取樞紐，會導致快速排序的性能變差",
        "reference_answer": [
            "快速排序選擇基準（pivot）的方法有：使用首尾元素、隨機選取或三數取中法。隨機選取能避免最壞情況，三數取中法則能更平衡分割數組，提升效率。"
        ],
        "score": "1",
        "comment": "不用填"
    },
    {
        "question": "為快速排序提出選擇樞紐(pivot)的方法，並簡短說明優點。",
        "student_answer": "可以選擇首尾元素作為樞紐，這樣的優點是實現簡單。",
        "reference_answer": [
            "快速排序選擇基準（pivot）的方法有：使用首尾元素、隨機選取或三數取中法。隨機選取能避免最壞情況，三數取中法則能更平衡分割數組，提升效率。"
        ],
        "score": "2",
        "comment": "不用填"
    },
    {
        "question": "為快速排序提出選擇樞紐(pivot)的方法，並簡短說明優點。",
        "student_answer": "首尾元素: 選擇首尾元素作為樞紐，這樣的優點是實現簡單。 隨機選取: 隨機選取樞紐，避免最壞情況。 三數取中法: 選擇三個元素中的中位數作為樞紐，可以更平衡地分割數組，提升效率。",
        "reference_answer": [
            "快速排序選擇基準（pivot）的方法有：使用首尾元素、隨機選取或三數取中法。隨機選取能避免最壞情況，三數取中法則能更平衡分割數組，提升效率。"
        ],
        "score": "3",
        "comment": "不用填"
    }
]